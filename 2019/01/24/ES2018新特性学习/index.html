<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ES2018新特性学习 · 曾洁仪博客</title><meta name="description" content="ES2018新特性学习 - Zeng Zoe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="css/googleapisFonts.css" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/zengjieyi1994" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ZENGzoe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><span style="display:none !important;"><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span></span></span><article class="post-block"><h1 class="post-title">ES2018新特性学习</h1><div class="post-time">2019年1月23日</div><div class="post-content"><p>ES全称ECMAScript，下面将会列出ES2018（ES9）中已经进入stage-4的新特性。</p>
<h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>ES2018新特性有：</p>
<p>1.对象的扩展运算符<br><br>2.正则表达式的改进<br><br>3.异步迭代器和异步生成器<br><br>4.Promise的finally回调</p>
<h2 id="一、对象的拓展运算符"><a href="#一、对象的拓展运算符" class="headerlink" title="一、对象的拓展运算符"></a>一、对象的拓展运算符</h2><p>拓展运算符，也叫Rest/Spread，在ES6时提出了数组的扩展运算符，仅用于数组，而在ES9中则新增了对象的拓展运算符。扩展运算符用<code>...</code>表示。</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><p><strong>ES6:</strong></p>
<p>example1:</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">const [a,b,...c] = arr;</span><br><span class="line"></span><br><span class="line">console.log(a,b); <span class="comment">//1 2</span></span><br><span class="line">console.log(c);  <span class="comment">//[3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>example2:</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">const nums = [<span class="number">23</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">3</span>];</span><br><span class="line">const result = Math.max(...nums);</span><br><span class="line"></span><br><span class="line">console.log(result);    <span class="comment">//23</span></span><br></pre></td></tr></table></figure>
<p><strong>ES9:</strong></p>
<p>example3:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">const obj = &#123; a : 1 , <span class="type">b</span> : 2 , <span class="type">c</span> : 3 , <span class="type">d</span> : 4&#125;;</span><br><span class="line">const &#123;a , b , ...z&#125; = obj;</span><br><span class="line"></span><br><span class="line">console.log(a,b);   //<span class="number">1</span> <span class="number">2</span></span><br><span class="line">console.log(z);     // &#123; c : 3 , <span class="type">d</span> : 4&#125;</span><br></pre></td></tr></table></figure>
<p>example4:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">const obj1 = &#123; a : 1 , <span class="type">b</span> : 2&#125;;</span><br><span class="line">const obj2 = &#123;c : 3 , <span class="type">d</span> : 4&#125;;</span><br><span class="line"></span><br><span class="line">const obj3 = &#123;...obj1 , ...obj2&#125;; //合并对象</span><br><span class="line"></span><br><span class="line">console.log(obj3);      //&#123; a : 1 , <span class="type">b</span> : 2 , <span class="type">c</span> : 3 , <span class="type">d</span> : 4&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>1.解构赋值必须是最后一个参数，否则会报错。</p>
<p>2.解构赋值的后的对象创建的是新的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; a : <span class="number">1</span>&#125;; </span><br><span class="line"><span class="keyword">const</span> &#123;...obj2&#125; = obj1; </span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj2);  <span class="comment">//&#123; a : 1&#125;</span></span><br><span class="line"></span><br><span class="line">obj1.a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(obj1);  <span class="comment">// &#123; a : 2&#125;</span></span><br><span class="line">console.<span class="built_in">log</span>(obj2);  <span class="comment">//&#123; a : 1&#125;</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="二、正则表达式的改进"><a href="#二、正则表达式的改进" class="headerlink" title="二、正则表达式的改进"></a>二、正则表达式的改进</h2><p>在ES9中，对于正则表达式的改进主要有四个方面：</p>
<p>1.位置运算符<br>2.Unicode转义<br>3.命名捕获组<br>4.修饰符s</p>
<h4 id="用法：-1"><a href="#用法：-1" class="headerlink" title="用法："></a>用法：</h4><h5 id="1-位置修饰符"><a href="#1-位置修饰符" class="headerlink" title="1.位置修饰符"></a>1.位置修饰符</h5><p>位置修饰符主要有四个：</p>
<p><strong><code>q?=p</code></strong> ：捕获q的后面是有p的字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /hello(?= world)/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello world sentences');    <span class="comment">//true</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello kugou');    <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong><code>q?!p</code></strong> ：捕获q的后面不为p的字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /hello(?= world)/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello world sentences');    <span class="comment">//false</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello kugou');    <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong><code>(?&lt;=q)p</code></strong> ：捕获p前面有q的字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /(?&lt;=hello) world/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello world sentences');    <span class="comment">//true</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a haha kugou');  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong><code>(?&lt;!q)p</code></strong> ：捕获p前面没有q的字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /(?&lt;!hello) world/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a hello world sentences');    <span class="comment">//false</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('a haha world');  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="2-Unicode转义"><a href="#2-Unicode转义" class="headerlink" title="2.Unicode转义"></a>2.Unicode转义</h5><p>Unicode转义可以通过<code>\p{...}</code>捕获，<code>\P{...}</code>捕获的是不符合转义的字符串。大括号内可以传入不同类型的unicode字符关键字，以下是不同unicode字符关键字的示例：</p>
<p><strong>ASCII</strong> ：捕获ASCII 字符集的字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /^\p&#123;ASCII&#125;+$/<span class="keyword">u</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('abc');    <span class="comment">//true</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('abc🙃');  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>ASCII_Hex_Digit</strong> ： 捕获16进制数字字符串</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">reg</span> = /^\p&#123;ASCII_Hex_Digit&#125;+$/<span class="keyword">u</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('012EF');  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">reg</span>.<span class="keyword">test</span>('<span class="keyword">G</span>');  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>Uppercase/Lowercase</strong> ： 捕获大或小写的字符串</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/\p&#123;Uppercase&#125;/u</span>.test(<span class="string">'A'</span>); <span class="regexp">//</span>true</span><br><span class="line"><span class="regexp">/\p&#123;Lowercase&#125;/u</span>.test(<span class="string">'a'</span>); <span class="regexp">//</span>true</span><br></pre></td></tr></table></figure>
<p><strong>White_Space</strong> ：捕获空格<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/\p&#123;White_Space&#125;/u</span>.test(<span class="string">' '</span>) <span class="regexp">//</span>true</span><br></pre></td></tr></table></figure></p>
<p><strong>Emoji</strong> ： 捕获emoji表情</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/\p&#123;Emoji&#125;/u</span>.test(<span class="string">'🙃'</span>);    <span class="regexp">//</span>true</span><br></pre></td></tr></table></figure>
<p>这里列出了部分的unicode关键字，还有其他更多可以查看<a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes" target="_blank" rel="noopener">https://github.com/tc39/proposal-regexp-unicode-property-escapes</a></p>
<h5 id="3-命名捕获组"><a href="#3-命名捕获组" class="headerlink" title="3.命名捕获组"></a>3.命名捕获组</h5><p>捕获结果中新增了<code>groups</code>对象，可以将捕获一些字段放入捕获结果的groups中。格式为<code>(?&lt;name&gt;Regexp)</code>，其中<code>name</code>为groups中的<code>key</code>值，可以通过该<code>key</code>值拿到捕获的结果，<code>Regexp</code>为要捕获的正则表达式。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = /(?&lt;<span class="built_in">year</span>&gt;\d&#123;<span class="number">4</span>&#125;)-(?&lt;<span class="built_in">month</span>&gt;\d&#123;<span class="number">2</span>&#125;)-(?&lt;<span class="built_in">day</span>&gt;\d&#123;<span class="number">2</span>&#125;)/</span><br><span class="line"><span class="keyword">const</span> result = reg.exec(<span class="string">'2015-01-02'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(reuslt.groups);	<span class="comment">//&#123;year: "2015", month: "01", day: "02"&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="4-修饰符s"><a href="#4-修饰符s" class="headerlink" title="4.修饰符s"></a>4.修饰符s</h5><p>增加了新的修饰符<code>s</code>，可以让<code>.</code>匹配任意的字符，包括换行符。又叫dot all。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/hello.world/</span>.test(<span class="string">'hello\nworld'</span>);	<span class="regexp">//</span>false</span><br><span class="line"><span class="regexp">/hello.world/</span>s.test(<span class="string">'hello\nworld'</span>);	<span class="regexp">//</span>true</span><br></pre></td></tr></table></figure>
<h2 id="三、异步迭代器和异步生成器"><a href="#三、异步迭代器和异步生成器" class="headerlink" title="三、异步迭代器和异步生成器"></a>三、异步迭代器和异步生成器</h2><h4 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h4><p>迭代器（Iterator）和生成器（Generator）于ES6中提出。</p>
<p>Iterator主要用于遍历不同的数据结构，遍历的数据结构要具有<code>Symbol.iterator</code>属性。Iterator中包含<code>next</code>方法，调用<code>next</code>方法可以返回两个值为<code>value</code>和<code>done</code>，<code>value</code>为返回的值，<code>done</code>为标识遍历是否结束，当为<code>false</code>时，遍历未结束，当为<code>true</code>时，遍历结束。ES6提供了<code>for...of</code>来遍历Iterator数据。</p>
<p>数组是默认具有<code>Symbol.iterator</code>属性的，以数组为例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr[<span class="built_in">Symbol</span>.iterator]);   <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//e</span></span><br></pre></td></tr></table></figure>
<p>Generator函数是ES6提供的一种异步解决方案。执行Generator函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。Generator函数有两个特征，一是<code>function</code>关键字与函数名之间有一个<code>*</code>号，二是函数体内部使用<code>yield</code>表达式，定义不同的内部状态。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'start'</span>);</span><br><span class="line">	<span class="built_in">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">yield</span> <span class="number">2</span>;</span><br><span class="line">	console.<span class="built_in">log</span>(<span class="string">'end'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const test = Test();</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(typeof test[Symbol.iterator]);  //<span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">test.next</span><span class="params">()</span></span>;    //start &#123;value: <span class="number">1</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">test.<span class="built_in">next</span>();    //&#123;value: <span class="number">2</span>, done: <span class="literal">false</span>&#125;</span><br><span class="line">test.<span class="built_in">next</span>();    //<span class="keyword">end</span> &#123;value: <span class="number">3</span>, done: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步迭代器和异步生成器"><a href="#异步迭代器和异步生成器" class="headerlink" title="异步迭代器和异步生成器"></a>异步迭代器和异步生成器</h4><p>异步迭代器与同步迭代器的区别在于，同步迭代器的<code>next</code>方法返回的是包含<code>value</code>和<code>done</code>的对象，异步迭代器的<code>next</code>方法返回的是promise对象，且promise对象回调中参数包含<code>value</code>和<code>done</code>对象。异步迭代器中包含的<code>Symbol.asyncIterator</code>属性。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">asyncIterator.next<span class="literal">()</span>.<span class="keyword">then</span>((&#123;<span class="keyword">value</span> , <span class="keyword">done</span>&#125;) =&gt; &#123;</span><br><span class="line">    console.log(<span class="keyword">value</span> , <span class="keyword">done</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>异步生成器与普通生成器在于，异步生成器的定义加入了<code>async</code>，且内部可以使用<code>await</code>，返回的是一个具有<code>Symbol.asyncIterator</code>方法的对象。因此可以用异步生成器创建异步迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> test = Test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test[<span class="built_in">Symbol</span>.asyncIterator]);    <span class="comment">//function</span></span><br></pre></td></tr></table></figure>
<p><code>for...of</code>只能用来遍历同步迭代器，因此ES9提供了<code>for...await...of</code>来遍历异步迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> item <span class="keyword">of</span> test)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="四、Promise的finally回调"><a href="#四、Promise的finally回调" class="headerlink" title="四、Promise的finally回调"></a>四、Promise的finally回调</h2><p>在ES9中，新增了Promise的<code>finally</code>回调函数，无论Promise返回结果是成功执行<code>then()</code>还是失败执行<code>catch()</code>，都会执行<code>finally</code>回调函数。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">function test(num)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve , reject)</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">			resolve()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			reject();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>).<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'success'</span>)</span><br><span class="line">&#125;).<span class="keyword">finally</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="regexp">//</span>success</span><br><span class="line"><span class="regexp">//</span><span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>).<span class="keyword">catch</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'error'</span>)</span><br><span class="line">&#125;).<span class="keyword">finally</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="regexp">//</span>error </span><br><span class="line"><span class="regexp">//</span><span class="keyword">finally</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://flaviocopes.com/es2018/" target="_blank" rel="noopener">1.THE ES2018 GUIDE</a><br><br><a href="https://juejin.im/post/5c0fd5a26fb9a049c30b17fe" target="_blank" rel="noopener">2.ES9中的异步迭代器（Async iterator）和异步生成器（Async generator）</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/01/24/如何用Phaser实现一个全家福拼图h5/" class="prev">PRVE</a><a href="/2018/11/18/面对JS的Event-Loop终于不懵逼/" class="next">NEXT</a></div><div data-thread-key="2019/01/24/ES2018新特性学习/" data-title="ES2018新特性学习" data-url="http://zengzoe.github.io/2019/01/24/ES2018新特性学习/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"zengzoe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2019 <a href="http://zengzoe.github.io">Zeng Zoe</a>, unless otherwise noted.</p><p style="display:none !important;"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span id="busuanzi_container_site_uv">本站总访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>