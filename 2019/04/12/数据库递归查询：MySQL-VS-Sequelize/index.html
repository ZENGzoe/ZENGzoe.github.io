<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据库递归查询：MySQL VS Sequelize · 曾洁仪博客</title><meta name="description" content="数据库递归查询：MySQL VS Sequelize - Zeng Zoe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="css/googleapisFonts.css" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/zengjieyi1994" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ZENGzoe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><section class="container"><div class="post"><span style="display:none !important;"><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span></span></span><article class="post-block"><h1 class="post-title">数据库递归查询：MySQL VS Sequelize</h1><div class="post-time">2019年4月12日</div><div class="post-content"><p><a href="#一、前言">一、前言</a><br><a href="#二、MySQL实现">二、MySQL实现</a><br><a href="#三、Sequqlize实现">三、Sequqlize实现</a><br><a href="#四、总结">四、总结</a><br><a href="#参考文档">参考文档</a></p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在做团队的排期系统改版时涉及到数据库的递归查询问题，有一个需求数据表，表中的需求数据以parentId为外键定义数据的继承关系，需求之间的关系呈现树状关系。需求数据表如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc needs;</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field    |<span class="built_in"> Type </span>       | <span class="literal">Null</span> | Key |<span class="built_in"> Default </span>| Extra          |</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id       | int(11)     | <span class="literal">NO</span>   | PRI | <span class="literal">NULL</span>    | auto_increment |</span><br><span class="line">| name     | varchar(45) | <span class="literal">YES</span>  |     | <span class="literal">NULL</span>    |                |</span><br><span class="line">| parentId | int(11)     | <span class="literal">YES</span>  |     | <span class="literal">NULL</span>    |                |</span><br><span class="line">+----------+-------------+------+-----+---------+----------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="builtin-name">set</span> (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>目前有这样的需求需要根据某个根需求，查找出全部的层级的子需求。</p>
<p>例如A需求的树状结构如下：</p>
<p><img src="/2019/04/12/数据库递归查询：MySQL-VS-Sequelize/needTree.jpg" alt="2019-04-12-数据库递归查询"></p>
<p>数据如下：<br><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; select <span class="symbol">*</span> from needs;</span><br><span class="line">+----+------+----------+</span><br><span class="line">|<span class="string"> id </span>|<span class="string"> name </span>|<span class="string"> parentId </span>|</span><br><span class="line">+----+------+----------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> A    </span>|<span class="string">     NULL </span>|</span><br><span class="line">|<span class="string">  2 </span>|<span class="string"> B    </span>|<span class="string">        1 </span>|</span><br><span class="line">|<span class="string">  3 </span>|<span class="string"> C    </span>|<span class="string">        1 </span>|</span><br><span class="line">|<span class="string">  4 </span>|<span class="string"> D    </span>|<span class="string">        2 </span>|</span><br><span class="line">|<span class="string">  5 </span>|<span class="string"> E    </span>|<span class="string">        2 </span>|</span><br><span class="line">|<span class="string">  6 </span>|<span class="string"> F    </span>|<span class="string">        3 </span>|</span><br><span class="line">|<span class="string">  7 </span>|<span class="string"> G    </span>|<span class="string">        3 </span>|</span><br><span class="line">|<span class="string">  8 </span>|<span class="string"> H    </span>|<span class="string">        5 </span>|</span><br><span class="line">|<span class="string">  9 </span>|<span class="string"> I    </span>|<span class="string">        5 </span>|</span><br><span class="line">|<span class="string"> 10 </span>|<span class="string"> J    </span>|<span class="string">        8 </span>|</span><br><span class="line">+----+------+----------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="二、MySQL实现"><a href="#二、MySQL实现" class="headerlink" title="二、MySQL实现"></a>二、MySQL实现</h2><h3 id="1-自定义函数实现"><a href="#1-自定义函数实现" class="headerlink" title="1.自定义函数实现"></a>1.自定义函数实现</h3><p>实现思路：首先根据子级<code>parenId</code>等于父级<code>id</code>的关系循环找出所有的层级关系数据的id，再拉出所有这些id的数据。</p>
<p><strong>（1）函数声明</strong></p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="comment">// </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="function"><span class="keyword">FUNCTION</span> `<span class="title">getParentList</span>`<span class="params">(rootId INT)</span></span></span><br><span class="line"><span class="function">    <span class="title">RETURNS</span> <span class="title">char</span><span class="params">(400)</span></span></span><br><span class="line"><span class="function">    <span class="title">BEGIN</span></span></span><br><span class="line"><span class="function">      <span class="title">DECLARE</span> <span class="title">fid</span> <span class="title">int</span> <span class="title">default</span> 1;</span></span><br><span class="line">      DECLARE str char(<span class="number">44</span>) <span class="keyword">default</span> rootId;</span><br><span class="line">      <span class="keyword">WHILE</span> rootId &gt; <span class="number">0</span> <span class="keyword">DO</span></span><br><span class="line">      <span class="keyword">SET</span> fid=(<span class="keyword">SELECT</span> parentId <span class="keyword">FROM</span> needs <span class="keyword">WHERE</span> id=rootId);</span><br><span class="line">     <span class="keyword">IF</span> fid &gt; <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">     <span class="keyword">SET</span> str=<span class="keyword">CONCAT</span>(str , <span class="string">','</span> , fid);</span><br><span class="line">     <span class="keyword">SET</span> rootId=fid;</span><br><span class="line">     <span class="keyword">ELSE</span> <span class="keyword">SET</span> rootId=fid;</span><br><span class="line">     <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">     <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">  return  str;</span><br><span class="line">  <span class="keyword">END</span> <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>DELIMITER</code>：定义MySQL的分隔符为<code>//</code>，默认分隔符是<code>;</code>，为了防止函数内使用<code>;</code>中断函数</p>
<p><code>CREATE FUNCTION 函数名(参数) RETURNS 返回值类型</code>：自定义函数</p>
<p><code>DECLARE</code>：声明变量</p>
<p><code>WHILE 条件 DO 循环体</code>：while循环</p>
<p><code>IF 条件 THEN 内容体 ELSE 内容体</code>：if判断</p>
<p><code>SET 变量=值</code>：存储值</p>
<p><code>CONCAT(str1,str2,...)</code>：函数，用于将多个字符串连接成一个字符串</p>
<p><br></p>
<p><strong>（2）函数调用</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">mysql&gt; DELIMITER;</span><br><span class="line"><span class="code">    -&gt; SELECT getNeedChild(1);</span></span><br><span class="line"><span class="code">+-----------------------+</span></span><br><span class="line">| getNeedChild(1)       |</span><br><span class="line"><span class="code">+-----------------------+</span></span><br><span class="line">| ,1,2,3,4,5,6,7,8,9,10 |</span><br><span class="line"><span class="code">+-----------------------+</span></span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>DELIMITER;</code>：由于之前执行了<code>DELIMITER //</code>修改了分隔符，因此需要重新调用修改分隔符为<code>;</code></p>
<p><code>SELECT 函数()</code>：调用函数并搜索出结果</p>
<p><br></p>
<p><strong>（3）结合FIND_IN_SET，拉取出所有的子需求</strong></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT <span class="symbol">*</span> FROM needs WHERE FIND_IN_SET(ID , getNeedChild(1));</span><br><span class="line">+----+------+----------+</span><br><span class="line">|<span class="string"> id </span>|<span class="string"> name </span>|<span class="string"> parentId </span>|</span><br><span class="line">+----+------+----------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> A    </span>|<span class="string">     NULL </span>|</span><br><span class="line">|<span class="string">  2 </span>|<span class="string"> B    </span>|<span class="string">        1 </span>|</span><br><span class="line">|<span class="string">  3 </span>|<span class="string"> C    </span>|<span class="string">        1 </span>|</span><br><span class="line">|<span class="string">  4 </span>|<span class="string"> D    </span>|<span class="string">        2 </span>|</span><br><span class="line">|<span class="string">  5 </span>|<span class="string"> E    </span>|<span class="string">        2 </span>|</span><br><span class="line">|<span class="string">  6 </span>|<span class="string"> F    </span>|<span class="string">        3 </span>|</span><br><span class="line">|<span class="string">  7 </span>|<span class="string"> G    </span>|<span class="string">        3 </span>|</span><br><span class="line">|<span class="string">  8 </span>|<span class="string"> H    </span>|<span class="string">        5 </span>|</span><br><span class="line">|<span class="string">  9 </span>|<span class="string"> I    </span>|<span class="string">        5 </span>|</span><br><span class="line">|<span class="string"> 10 </span>|<span class="string"> J    </span>|<span class="string">        8 </span>|</span><br><span class="line">+----+------+----------+</span><br><span class="line">10 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>
<p><code>FIND_IN_SET(str,strlist)</code>：函数，查询字段<code>strlist</code>中包含<code>str</code>的结果，<code>strlist</code>中以<code>,</code>分割各项</p>
<p><br></p>
<h3 id="2-递归CTE实现"><a href="#2-递归CTE实现" class="headerlink" title="2.递归CTE实现"></a>2.递归CTE实现</h3><p><strong>（1）递归CTE介绍</strong></p>
<p>CTE（common table expression）为公共表表达式，可以对定义的表达式进行自引用查询。在MySQL 8.0版以上才支持。</p>
<p>递归CTE由三个部分组成：初始查询部分、递归查询部分、终止递归条件。</p>
<p>语法如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> RECURSIVE cte_name AS(</span><br><span class="line">    initial_query       <span class="comment">-- 初始查询部分</span></span><br><span class="line">    UNION <span class="keyword">ALL</span>           <span class="comment">-- 递归查询与初始查询部分连接查询</span></span><br><span class="line">    recursive_query     <span class="comment">-- 递归查询部分</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * FROM cte_name</span><br></pre></td></tr></table></figure>
<p>更多CTE介绍可以查看文档：<a href="http://www.mysqltutorial.org/mysql-recursive-cte/" target="_blank" rel="noopener">A Definitive Guide To MySQL Recursive CTE</a></p>
<p><br></p>
<p><strong>（2）递归CTE实现</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE needsTree AS</span><br><span class="line">( <span class="keyword">SELECT</span> <span class="keyword">id</span>,</span><br><span class="line">         <span class="keyword">name</span>,</span><br><span class="line">         parentId,</span><br><span class="line">         <span class="number">1</span> lvl</span><br><span class="line">    <span class="keyword">FROM</span> needs</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> </span><br><span class="line">  <span class="keyword">UNION</span> ALL</span><br><span class="line">  <span class="keyword">SELECT</span> nd.id,</span><br><span class="line">         nd.name,</span><br><span class="line">         nd.parentId,</span><br><span class="line">         lvl+<span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> needs <span class="keyword">AS</span> nd</span><br><span class="line">    <span class="keyword">JOIN</span> needsTree <span class="keyword">AS</span> nt <span class="keyword">ON</span> nt.id = nd.parentId </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> needsTree <span class="keyword">ORDER</span> <span class="keyword">BY</span> lvl;</span><br></pre></td></tr></table></figure>
<p>实现解释：</p>
<p>初始查询部分：找出一级需求</p>
<p>递归查询部分：找出子级需求</p>
<p>终止递归条件：子级的<code>parentId</code>等于父级的<code>id</code></p>
<p>查询结果：</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">+------+------+----------+------+</span><br><span class="line">|<span class="string"> id   </span>|<span class="string"> name </span>|<span class="string"> parentId </span>|<span class="string"> lvl  </span>|</span><br><span class="line">+------+------+----------+------+</span><br><span class="line">|<span class="string">    1 </span>|<span class="string"> A    </span>|<span class="string"> NULL     </span>|<span class="string">    1 </span>|</span><br><span class="line">|<span class="string">    2 </span>|<span class="string"> B    </span>|<span class="string"> 1        </span>|<span class="string">    2 </span>|</span><br><span class="line">|<span class="string">    3 </span>|<span class="string"> C    </span>|<span class="string"> 1        </span>|<span class="string">    2 </span>|</span><br><span class="line">|<span class="string">    6 </span>|<span class="string"> F    </span>|<span class="string"> 3        </span>|<span class="string">    3 </span>|</span><br><span class="line">|<span class="string">    7 </span>|<span class="string"> G    </span>|<span class="string"> 3        </span>|<span class="string">    3 </span>|</span><br><span class="line">|<span class="string">    4 </span>|<span class="string"> D    </span>|<span class="string"> 2        </span>|<span class="string">    3 </span>|</span><br><span class="line">|<span class="string">    5 </span>|<span class="string"> E    </span>|<span class="string"> 2        </span>|<span class="string">    3 </span>|</span><br><span class="line">|<span class="string">    8 </span>|<span class="string"> H    </span>|<span class="string"> 5        </span>|<span class="string">    4 </span>|</span><br><span class="line">|<span class="string">    9 </span>|<span class="string"> I    </span>|<span class="string"> 5        </span>|<span class="string">    4 </span>|</span><br><span class="line">|<span class="string">   10 </span>|<span class="string"> J    </span>|<span class="string"> 8        </span>|<span class="string">    5 </span>|</span><br><span class="line">+------+------+----------+------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="三、Sequqlize实现"><a href="#三、Sequqlize实现" class="headerlink" title="三、Sequqlize实现"></a>三、Sequqlize实现</h2><h3 id="1-Sequelize介绍"><a href="#1-Sequelize介绍" class="headerlink" title="1.Sequelize介绍"></a>1.Sequelize介绍</h3><p>Sequelize是Node.js的ORM框架，能够把关系数据库的表结构映射到对象上，支持数据库Postgres、MySQL、 MariaDB、 SQLite and Microsoft SQL Server。在这次的排期系统后台开发中，我选择了该框架来操作数据库，可以更方便地处理数据。</p>
<p>更多Sequelize介绍可以查看官方文档：<a href="http://docs.sequelizejs.com/" target="_blank" rel="noopener">Sequelize官方文档</a>。</p>
<h3 id="2-递归实现"><a href="#2-递归实现" class="headerlink" title="2.递归实现"></a>2.递归实现</h3><p><strong>1.连接mysql数据库</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Sequelize = <span class="built_in">require</span>(<span class="string">'sequelize'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequelize = <span class="keyword">new</span> Sequelize(<span class="string">'schedule'</span> , <span class="string">'root'</span> , <span class="string">'12345678'</span> , &#123;</span><br><span class="line">    host : <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    dialect : <span class="string">'mysql'</span>,</span><br><span class="line">    port : <span class="string">'3306'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sequelize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>new Sequelize(databse , username , password , options)</code>：实例化Sequelize，连接数据库</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">options</span> = &#123;</span><br><span class="line">    host,   <span class="comment">//数据库主机</span></span><br><span class="line">    dialect,    <span class="comment">//数据库</span></span><br><span class="line">    port        <span class="comment">//数据库端口号，默认为3306</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>2.定义数据表的schema模型表</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">module.exports</span> <span class="string">=</span> <span class="string">function(sequelize,</span> <span class="string">DataTypes)</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">sequelize.define('needs',</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    id:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">DataTypes.INTEGER(11),</span></span><br><span class="line"><span class="attr">      allowNull:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">      primaryKey:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">      autoIncrement:</span> <span class="literal">true</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">DataTypes.STRING(45),</span></span><br><span class="line"><span class="attr">      allowNull:</span> <span class="literal">false</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">    parentId:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      type:</span> <span class="string">DataTypes.INTEGER(11),</span></span><br><span class="line"><span class="attr">      allowNull:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">&#125;,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    tableName:</span> <span class="string">'needs'</span><span class="string">,</span></span><br><span class="line"><span class="attr">    timestamps:</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">&#125;);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>sequelize.define(modelName , attribute , options)</code>：定义数据表的模型，相当于定义数据表。</p>
<p><code>attribute</code>：一个对象，为数据表对应的列项，<code>key</code>值为对应的列项名，<code>value</code>为对应列项的定义，比如数据类型、是否主键、是否必需等</p>
<p><code>options</code>：数据表的一些配置。比如对应的数据表名<code>tableName</code>、是否需要时间戳<code>timestamp</code>等</p>
<p><br></p>
<p>3.导入数据表模型</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; sequelize &#125; = require(<span class="string">'../config/db'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入数据表模型</span></span><br><span class="line"><span class="keyword">const</span> Needs = sequelize.<span class="keyword">import</span>(<span class="string">'./needs.js'</span>);</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>sequelize.import(path)</code>：导入数据表模型</p>
<p><br></p>
<p>4.递归查询</p>
<p>实现思路：跟CTE实现思路相似，先找出找出一级需求，再递归找出子需求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeedModule</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(id)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> getNeedsTree()&#123;</span><br><span class="line">        <span class="keyword">let</span> rootNeeds = <span class="keyword">await</span> Needs.findAll(&#123;</span><br><span class="line">            where : &#123; </span><br><span class="line">                id : <span class="keyword">this</span>.id </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        rootNeeds = <span class="keyword">await</span> <span class="keyword">this</span>.getChildNeeds(rootNeeds);</span><br><span class="line">        <span class="keyword">return</span> rootNeeds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> getChildNeeds(rootNeeds)&#123;</span><br><span class="line">        <span class="keyword">let</span> expendPromise = [];</span><br><span class="line">        rootNeeds.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            expendPromise.push(Needs.findAll(&#123;</span><br><span class="line">                where : &#123;</span><br><span class="line">                    parentId : item.id</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">let</span> child = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(expendPromise);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> [idx , item] <span class="keyword">of</span> child.entries())&#123;</span><br><span class="line">            <span class="keyword">if</span>(item.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                item = <span class="keyword">await</span> getChildNeeds(item);</span><br><span class="line">            &#125;</span><br><span class="line">            rootNeeds[idx].child = item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rootNeeds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>findALL(options)</code>：查询多条数据</p>
<p><code>options</code>：查询配置</p>
<ul>
<li><code>options.where</code>：查询条件</li>
</ul>
<p>查询结果如下：</p>
<p><img src="/2019/04/12/数据库递归查询：MySQL-VS-Sequelize/sequelizeResult.jpg" alt="2019-04-12-数据库递归查询"></p>
<p>从搜索结果可以看出，使用Sequelize查询可以更好的给层级数据划分层级存储。</p>
<p><br></p>
<h3 id="3-nested属性实现"><a href="#3-nested属性实现" class="headerlink" title="3.nested属性实现"></a>3.nested属性实现</h3><p>Sequelize的<code>findAll</code>方法中的<code>nested</code>属性可以根据连接关系找出继承关系的数据。</p>
<p><strong>1.定义表关系</strong></p>
<p>由于需要需求表进行自连接查询，因此需要先定义表关系。需求表自身关系以父需求为主查询是一对多关系，因此使用<code>hasMany</code>定义关系。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Needs</span><span class="selector-class">.hasMany</span>(</span><br><span class="line">    <span class="selector-tag">Needs</span>, </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">as</span>: <span class="string">'child'</span>, </span><br><span class="line">        foreignKey: <span class="string">'parentId'</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>sourceModel.hasMany(targetModel, options)</code>：定义源模型和目标模型的表是一对多关系，外键会添加到目标模型中</p>
<p><code>options</code>：定义表关系的一些属性。如<code>as</code>定义连接查询时，目标模型的别名。<code>foreignKey</code>为外键名。</p>
<p><strong>2.自连接查询</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">async</span> <span class="selector-tag">getNeedTree</span>(id)&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">await</span> <span class="selector-tag">Needs</span><span class="selector-class">.findAll</span>(&#123;</span><br><span class="line">        <span class="attribute">where </span>: &#123;</span><br><span class="line">            id </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attribute">include </span>: &#123;</span><br><span class="line">            <span class="attribute">model</span>: Needs,</span><br><span class="line">            <span class="attribute">as</span>:<span class="string">'child'</span>, </span><br><span class="line">            <span class="attribute">required </span>: false,</span><br><span class="line">            <span class="attribute">include </span>: &#123;</span><br><span class="line">                <span class="attribute">all </span>: true,</span><br><span class="line">                <span class="attribute">nested </span>: true,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法解释：</p>
<p><code>include</code>：连接查询列表</p>
<ul>
<li><p><code>include.model</code>：连接查询的模型</p>
</li>
<li><p><code>include.as</code>：连接查询模型的别名</p>
</li>
<li><p><code>include.requeired</code>：如果为<code>true</code>，连接查询为内连接。<code>false</code>为左连接。如果有<code>where</code>默认为<code>true</code>，其他情况默认为<code>false</code>。</p>
</li>
<li><p><code>include.all</code>：嵌套查询所有的模型</p>
</li>
<li><p><code>include.nested</code>：嵌套查询</p>
</li>
</ul>
<p>使用此方法，查询最深的子级结果为三层。如果能保证数据继承关系最深为三层，可以使用此方法。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>在MySQL 8+可以使用CTE实现，相对于自定义函数实现可以使用更少的代码量实现，且使用<code>WITH...AS</code>可以优化递归查询。Sequelize目前支持CTE，但仅支持PostgreSQL、SQLite、MSSQL数据库，如果有更好的实现方式，可以分享下哦(≧▽≦)</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.cnblogs.com/xiaoxi/p/5942805.html" target="_blank" rel="noopener">1.mysql 递归查询 http://www.cnblogs.com/xiaoxi/p/5942805.html</a></p>
<p><a href="http://www.mysqltutorial.org/mysql-adjacency-list-tree/" target="_blank" rel="noopener">2.Managing Hierarchical Data in MySQL Using the Adjacency List Model</a></p>
<p><a href="http://www.mysqltutorial.org/mysql-recursive-cte/" target="_blank" rel="noopener">3.A Definitive Guide To MySQL Recursive CTE</a></p>
<p><a href="http://docs.sequelizejs.com/" target="_blank" rel="noopener">4.http://docs.sequelizejs.com/</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2019/01/24/如何用Phaser实现一个全家福拼图h5/" class="next">NEXT</a></div><div data-thread-key="2019/04/12/数据库递归查询：MySQL-VS-Sequelize/" data-title="数据库递归查询：MySQL VS Sequelize" data-url="http://zengzoe.github.io/2019/04/12/数据库递归查询：MySQL-VS-Sequelize/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"zengzoe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2019 <a href="http://zengzoe.github.io">Zeng Zoe</a>, unless otherwise noted.</p><p style="display:none !important;"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span id="busuanzi_container_site_uv">本站总访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>