<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 讲讲ECMAScript 6那些事 · 曾洁仪博客</title><meta name="description" content="讲讲ECMAScript 6那些事 - Zeng Zoe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="css/googleapisFonts.css" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/zengjieyi1994" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ZENGzoe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><span style="display:none !important;"><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span></span></span><article class="post-block"><h1 class="post-title">讲讲ECMAScript 6那些事</h1><div class="post-time">2016年9月14日</div><div class="post-content"><p>ECMAScript 6（下面简称ES6）已于2015年6月正式发布，它提供的许多新的语法特性，将会成为Javascript语言新的标准。</p>
<p>ES6发布至今，许多浏览器的最新版本对ES6大部分特性都实现了,但是没有浏览器对ES6全部特性能够完美的支持,可以通过<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a>查看浏览器的支持情况。如果想要更好的体验ES6的新特性和新语法，可以使用转换器，将ES6转换成ES5。</p>
<p>ES6的出现，给前端开发者们带来不一样的体验，使用ES6可以更加方便的实现很多复杂的功能，提高前端开发者的效率。这篇博客将会介绍ES6比较常用的语法特性，希望能够给大家带来收获。在线测试代码可以点击<a href="http://babeljs.cn/repl/" target="_blank" rel="noopener">这里</a>。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p> <strong> <a href="#var">1.let和const</a> </strong><br> <strong> <a href="#arrow">2.箭头函数</a> </strong><br> <strong> <a href="#string">3.字符串</a> </strong><br> <strong> <a href="#deconstruct">4.解构赋值</a> </strong><br> <strong> <a href="#parameter">5.函数参数</a> </strong><br> <strong> <a href="#class">6.类 class</a> </strong><br> <strong> <a href="#symbols">7.Symbols</a> </strong><br> <strong> <a href="#for">8.for…of循环</a> </strong><br> <strong> <a href="#setAndMap">9.Set和Map数据解构</a> </strong><br> <strong> <a href="#promise">10.Promise</a> </strong><br> <strong> <a href="#generators">11.Generators生成器</a> </strong></p>
<hr>
<h2 id="1-let和const"><a href="#1-let和const" class="headerlink" title="1.let和const"></a><span id="var">1.let和const</span></h2><p><code>let</code>和<code>const</code>是ES6新增的声明变量的命令。使用方法与<code>var</code>相似，不过<code>let</code>和<code>const</code>声明的变量只能在所在的代码块使用，也就是块级作用域。</p>
<p><strong> <code>Const</code> </strong><br><code>const</code>即constant，用来声明只读的常量，一旦声明就必须赋值，声明常量之后不可赋值，但是可以继续添加属性。<br>（1）<code>const</code>声明常量时必须赋值，否则报错：<br><figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Pi;  // Missing initializer <span class="keyword">in</span> <span class="keyword">const</span> declaration</span><br></pre></td></tr></table></figure></p>
<p>（2）由于<code>const</code>声明的Pi是常量，如果初始化后对其赋值，则报错：<br><figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Pi</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">Pi</span> = <span class="number">3</span>;     //Assignment <span class="keyword">to</span> constant variable.</span><br></pre></td></tr></table></figure></p>
<p>（3）常量<code>obj</code>是一个对象，可以对其添加属性，但不可以再次赋值：<br><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">const obj = &#123;&#125;<span class="comment">;</span></span><br><span class="line">obj.name = <span class="string">"张三"</span><span class="comment">;</span></span><br><span class="line">console.log(obj)<span class="comment">;           // &#123;name: "张三"&#125;</span></span><br><span class="line"><span class="attribute">obj</span> = &#123;&#125;<span class="comment">;              //Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></p>
<p><strong> <code>let</code> </strong><br><code>let</code>其与<code>var</code>相似，它们的不同体现在三点：<br>（1）不存在变量提升<br>使用<code>var</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getStr</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">            <span class="keyword">var</span> str = <span class="string">'hello world'</span>;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(getStr(<span class="literal">false</span>));  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>使用<code>let</code>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStr</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arg) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">'hello world'</span>;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getStr(<span class="literal">false</span>));  <span class="comment">//hello</span></span><br></pre></td></tr></table></figure></p>
<p>第一个例子中，由于if内声明的变量会被提升到函数头部，所以返回了undefined。第二个例子由于let声明的变量不会发生变量提升，if内声明的变量只能在当前所在的代码块使用，所以直接返回hello。</p>
<p>（2）暂时性死区<br><code>let</code>声明的变量只能在代码块中使用，同时必须在声明后才能使用，否则会报错,这就是暂时性死区。<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">str</span>);       <span class="comment">//ReferenceError: str is not defined</span></span><br><span class="line">    <span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>let</code>命令声明str之前，上面的代码都属于str的”死区”。<br>如果将上面的<code>let</code>变成<code>var</code>,则返回undefined：<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">str</span>);       <span class="comment">//undefined</span></span><br><span class="line">    var <span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）不允许重复声明<br><code>let</code>不允许在相同的作用域内，重复声明同一个变量。而<code>var</code>重复声明变量，则后面的变量会覆盖前面声明的变量。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(str); <span class="comment">//SyntaxError: Identifier 'str' has already been declared</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，对于<code>const</code>、<code>let</code>和<code>var</code>三个命令，当想要定义常量的时候可以选择<code>const</code>。当声明一个变量赋值后还会修改的可以选择<code>let</code>或<code>var</code>，当使用于循环计数或者算法，建议优先选择<code>let</code>。</p>
<hr>
<h2 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2.箭头函数"></a><span id="arrow">2.箭头函数</span></h2><p>当我们使用闭包的时候，函数内部的this总是发生改变，不能指向我们所预期的对象。而箭头函数的出现，正是可以让函数里面this指向预期的对象。另外，箭头函数的出现，还可以让我们的代码量大大减少。<br>箭头函数即使用箭头“=&gt;”定义函数，用法如下：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">let result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(i=&gt;i*i);</span><br></pre></td></tr></table></figure></p>
<p>箭头的左边是输入的参数，右边是进行的操作以及返回的值。<br>上面代码等同于es5：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">let rusult = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="keyword">function</span><span class="params">(i)</span>&#123;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">i</span>*<span class="built_in">i</span>;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
<p>从上两段代码中可以看出，箭头函数在一定程度上可以减少代码量，使得我们的代码更加简洁。<br>（1）如果函数不需要参数或者需要多个参数，需使用用圆号。<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">let result = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">let result2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="params">(i,item)</span>=&gt;</span><span class="built_in">console</span>.log(i:item));</span><br></pre></td></tr></table></figure></p>
<p>（2）如果箭头右边执行多行命令，则需使用大括号,并使用return返回。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].map(<span class="function"><span class="params">i</span>=&gt;</span>&#123;<span class="keyword">return</span> i*i;&#125;)</span><br></pre></td></tr></table></figure></p>
<p>（3）如果返回的是对象，则需在大括号外层添加中括号。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let result = <span class="selector-tag">i</span> =&gt; (&#123;id :<span class="selector-tag">i</span> ,name : <span class="string">"cici"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>（4）可代替立即执行函数。<br><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">x</span> =&gt; x*2)(<span class="name">3</span>)<span class="comment">;      //6</span></span><br></pre></td></tr></table></figure></p>
<p>（5）在箭头函数，<code>this</code>指向的是定义时所在的对象，而不是使用时所在的对象。<br>例子：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = data.name;</span><br><span class="line">    <span class="keyword">this</span>.age = data.ag;</span><br><span class="line">    <span class="keyword">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dudu = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name : <span class="string">"dudu"</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dudu.getInfo();       <span class="comment">//dudu 20</span></span><br><span class="line">dudu.sayHello();      <span class="comment">//windows</span></span><br></pre></td></tr></table></figure></p>
<p>在超时调用的代码都是在全局作用于中执行，所以函数中的<code>this</code>的值指向了window对象。而箭头函数可以保持作用域，保证<code>this</code>的指向不会变:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = data.name;</span><br><span class="line">    <span class="keyword">this</span>.age = data.age;</span><br><span class="line">    <span class="keyword">this</span>.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" "</span> + <span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>),<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dudu = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name : <span class="string">"dudu"</span>,</span><br><span class="line">    age : <span class="number">20</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dudu.getInfo();               <span class="comment">//dudu 20</span></span><br><span class="line">dudu.sayHello();             <span class="comment">//Person &#123;name: "dudu", age: 20&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>在sayHello函数中，使用了箭头函数，当前作用域是在person对象的一个方法中，箭头函数生成的临时函数的作用域也就是person对象的作用域。</p>
<hr>
<h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a><span id="string">3.字符串</span></h2><p>在ES6中，添加了许多对于字符串的接口，使得更加的便利地去处理字符串。<br><strong> (1) 模版字符串 </strong><br>以前我们需要拼接字符串跟变量时，需要使用“+”进行拼接。而模板字符串的出现可以让变量嵌入到字符串中，可以让代码变得更加简单。同时，模板字符串还可保留换行符空白符，可以让字符串的定义更加方便。</p>
<p><strong> a.可以在字符串中是使用变量 </strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"dudu"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;name&#125;</span>,i am <span class="subst">$&#123;age&#125;</span> years old`</span>);     <span class="comment">// "my name is dudu,i am 20 years old"</span></span><br></pre></td></tr></table></figure></p>
<p>在模版字符串中，使用<code>${}</code>包含变量。也可在变量进行算法运算或执行函数等操作。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`5加10等于<span class="subst">$&#123;a+b&#125;</span>，5乘10等于<span class="subst">$&#123;a*b&#125;</span>`</span>)    <span class="comment">//5加10等于15，5乘10等于50</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`5加10等于<span class="subst">$&#123;add(a,b)&#125;</span>`</span>)           <span class="comment">//5加10等于15</span></span><br></pre></td></tr></table></figure></p>
<p><strong> b.字符串换行符空白符被保留 </strong><br>在ES6之前：<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hi,"</span></span><br><span class="line">          + <span class="string">"i am dudu"</span> </span><br><span class="line">          + <span class="string">"i am 20 years old"</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>);           <span class="comment">//hi,i am dudui am 20 years old</span></span><br></pre></td></tr></table></figure></p>
<p>ES6：<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str2 = `hi,</span><br><span class="line">            i am dudu,</span><br><span class="line">            i am <span class="number">20</span> years old`;</span><br><span class="line">console.log(str2);</span><br><span class="line"><span class="comment">//hi,</span></span><br><span class="line"><span class="comment">//i am dudu,</span></span><br><span class="line"><span class="comment">// i am 20 years old</span></span><br></pre></td></tr></table></figure></p>
<p>通过上面的示例可以看出，模版字符串的出现给字符串的使用带了很大的便利。</p>
<p><strong>（2）includes、startsWith、endsWith </strong><br>之前我们是通过<code>indexOf</code>来判断字符串是否包含某个字符串：<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"hello world"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">"o"</span>)&gt;-<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>而在ES6中，增加了三个新方法的进行检索。<br><code>includes</code>判断字符串是否包含某字符串，返回布尔值。<br><code>startsWith</code>判断字符串是否以某字符串开头，返回布尔值。<br><code>endsWith</code>判断字符串是否以某字符串结尾，返回布尔值。<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">let <span class="built_in">str</span> = <span class="string">"hello world"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">"wor"</span>));       <span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.startsWith(<span class="string">"he"</span>));       <span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.endsWith(<span class="string">"ld"</span>));       <span class="comment">//true</span></span><br><span class="line">  </span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">"llo"</span>,<span class="number">1</span>));         <span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.includes(<span class="string">"llo"</span>,<span class="number">5</span>));        <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.startsWith(<span class="string">"llo"</span>,<span class="number">2</span>));        <span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.startsWith(<span class="string">"llo"</span>,<span class="number">3</span>));        <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.endsWith(<span class="string">"llo"</span>,<span class="number">5</span>));        <span class="comment">//true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.endsWith(<span class="string">"llo"</span>,<span class="number">9</span>));        <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p>在上面代码中，加入了第二个参数。<code>includes</code>和<code>startsWith</code>的第二个参数代表搜索的开始位置。而<code>endsWith</code>代表了只搜索字符串的前几位。</p>
<p><strong> (3) repeat </strong><br><code>repeat</code>方法用来返回重复多次的字符串。<br><figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">str</span> = <span class="string">"abc"</span>;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(<span class="number">2</span>));         <span class="comment">// "abcabc"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(<span class="string">"3"</span>));         <span class="comment">// "abcabc"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(<span class="string">"2.8"</span>));        <span class="comment">// "abcabc"</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(<span class="string">"a"</span>));           <span class="comment">// ""   </span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat());              <span class="comment">// ""</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(<span class="number">0</span>));              <span class="comment">// ""</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.repeat(-<span class="number">1</span>));            <span class="comment">// 报错：  Uncaught RangeError: Invalid count value</span></span><br></pre></td></tr></table></figure></p>
<p><code>repeat</code>参数为重复字符串的次数，如果参数是字符串，则会先转换成数字，否则输出空字符串；如果是小数，则会被去整；如果参数是0或者不添加参数，则返回空字符串；如果是负数，则会报错。</p>
<hr>
<h2 id="4-解构赋值"><a href="#4-解构赋值" class="headerlink" title="4.解构赋值"></a><span id="deconstruct">4.解构赋值</span></h2><p>解构赋值可以从数组或对象中提取出值为赋值给不同的变量。<br><strong> （1）数组的解构赋值 </strong><br>ES6之前：<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var arr</span> = [1,2,3];</span><br><span class="line"><span class="attribute">var a</span> = arr[0];</span><br><span class="line"><span class="attribute">var b</span> = arr[1];</span><br><span class="line"><span class="attribute">var c</span> = arr[2];</span><br></pre></td></tr></table></figure></p>
<p>ES6:<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">let [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">console.log(a,b,c);     <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure></p>
<p>数组的解构赋值按照数据的变量顺序进行赋值。</p>
<p><strong> （2）对象的解构赋值 </strong><br>ES6之前：<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var obj</span> = &#123;name : <span class="string">"dudu"</span>,age : 20,city : <span class="string">"shenzhen"</span>&#125;;</span><br><span class="line"><span class="attribute">var name</span> = obj.name;</span><br><span class="line"><span class="attribute">var age</span> = obj.age;</span><br><span class="line"><span class="attribute">var city</span> = obj.city;</span><br></pre></td></tr></table></figure></p>
<p>ES6:<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">let &#123;<span class="built_in">name</span>,age,city&#125; = &#123;<span class="built_in">name</span> : <span class="string">"dudu"</span>,age : <span class="number">20</span>,city : <span class="string">"shenzhen"</span>&#125;;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">name</span>,age,city);</span><br></pre></td></tr></table></figure></p>
<p>对象的解构赋值顺序可以打乱，按照变量名进行赋值。</p>
<p><strong> （3）字符串的解构赋值 </strong><br>ES6之前：<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var str</span> = <span class="string">"hello"</span>;</span><br><span class="line"><span class="attribute">var a</span> = str[0];</span><br><span class="line"><span class="attribute">var b</span> = str[1];</span><br><span class="line"><span class="attribute">var c</span> = str[2];</span><br><span class="line"><span class="attribute">var d</span> = str[3];</span><br><span class="line"><span class="attribute">var e</span> = str[4];</span><br></pre></td></tr></table></figure></p>
<p>ES6：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a,b,c,d,e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a,b,c,d,e);        <span class="comment">//h e l l o</span></span><br></pre></td></tr></table></figure></p>
<p><strong> (4)函数参数的解构赋值 </strong><br>函数参数的解构赋值最大的特点是能够为参数设定默认值。<br>ES6之前：<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">function foo(<span class="built_in">name</span>,age)&#123;</span><br><span class="line">    <span class="built_in">name</span> = <span class="built_in">name</span> || <span class="string">"dudu"</span>;</span><br><span class="line">    age = age || <span class="number">20</span>;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="built_in">name</span>,age);</span><br><span class="line">&#125;</span><br><span class="line">foo();              <span class="comment">//dudu 20</span></span><br><span class="line">foo(<span class="string">"haha"</span>,<span class="number">21</span>)         <span class="comment">//haha 21</span></span><br></pre></td></tr></table></figure></p>
<p>ES6:<br><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> foo(&#123;name=<span class="string">"dudu"</span>,age=<span class="number">20</span>&#125; = &#123;&#125;)&#123;</span><br><span class="line">    console.log([name,age]);</span><br><span class="line">&#125;</span><br><span class="line">foo();       //[<span class="string">"dudu"</span>, <span class="number">20</span>]</span><br><span class="line">foo(&#123;&#125;)     //[<span class="string">"dudu"</span>, <span class="number">20</span>]</span><br><span class="line">foo(&#123;name : <span class="string">"cici"</span>&#125;) //[<span class="string">"cici"</span>, <span class="number">20</span>]</span><br><span class="line">foo(&#123;age : <span class="number">22</span>&#125;); //[<span class="string">"dudu"</span>, <span class="number">22</span>]</span><br><span class="line">foo(&#123;name : <span class="string">"cici"</span>,age :<span class="number">22</span>&#125;);//[<span class="string">"cici"</span>, <span class="number">22</span>]</span><br></pre></td></tr></table></figure></p>
<p>注意下面代码参数的写法与上面代码参数的写法不同：<br><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">function foo(&#123;name,age&#125; = &#123;<span class="string">name :</span> <span class="string">"dudu"</span>,<span class="string">age :</span> <span class="number">20</span>&#125;)&#123;</span><br><span class="line">    console.log([name,age]);</span><br><span class="line">&#125;</span><br><span class="line">foo();   <span class="comment">//["dudu", 20]</span></span><br><span class="line">foo(&#123;&#125;);         <span class="comment">//[undefined, undefined]</span></span><br><span class="line">foo(&#123;<span class="string">name :</span> <span class="string">"cici"</span>&#125;)     <span class="comment">//["cici", undefined]</span></span><br><span class="line">foo(&#123;<span class="string">age :</span> <span class="number">22</span>&#125;);         <span class="comment">//[undefined, 22]</span></span><br><span class="line">foo(&#123;<span class="string">name :</span> <span class="string">"cici"</span>,<span class="string">age :</span><span class="number">22</span>&#125;);        <span class="comment">//["cici", 22]</span></span><br></pre></td></tr></table></figure></p>
<p>第一个代码块中，是为参数中对象的每一个名赋值，第二个代码块中是直接为对象赋值。</p>
<hr>
<h2 id="5-函数参数"><a href="#5-函数参数" class="headerlink" title="5.函数参数"></a><span id="parameter">5.函数参数</span></h2><p>ES6在函数参数上新增加了默认参数、不定参数等。<br><strong> （1）默认参数 </strong><br>ES6之前：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x,y)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    x = x || 1;</span></span></span><br><span class="line"><span class="function"><span class="comment">    y = y || 2;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(x,y)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span>;</span>  <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure></p>
<p>ES6：<br><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x = 1,y = 2)</span><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    console.log(x,y)</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span>;</span>  <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure></p>
<p><strong> (2) 不定参数 </strong><br>ES6中函数的不定参数通过（…变量名）实现，用来获取函数多余的参数。<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="rest_arg">...value</span>)</span></span>&#123;</span><br><span class="line">    let sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> val of value)&#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(sum);</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p>
<p>不定参数与arguments的区别是，不定参数中的变量代表的是一个数组，可以使用数组的所有方法，而arguments是类数组，只能用length属性。</p>
<hr>
<h2 id="6-类-class"><a href="#6-类-class" class="headerlink" title="6.类 class"></a><span id="class">6.类 class</span></h2><p>ES6为了更接近传统语言的写法，提出了类的写法，作为对象的模版,通过关键字class来定义类。<br>ES6之前：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age,<span class="keyword">this</span>.sex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6:<br><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age,sex)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age ;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">       console.log(<span class="keyword">this</span>.name,<span class="keyword">this</span>.age,<span class="keyword">this</span>.sex)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，<code>constructor</code>方法就是构造方法。使用的时候直接用<code>new</code>命令,自动调用<code>constructor</code>方法。如果没有显示定义<code>constructor</code>方法，则会自动添加空的<code>constructor</code>。<br><figure class="highlight ceylon"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person<span class="number">1</span> = <span class="keyword">new</span> Person(<span class="string">"dudu"</span>,<span class="number">20</span>,<span class="string">"women"</span>);</span><br><span class="line">person<span class="number">1</span>.getInfo();  <span class="comment">//dudu 20 women</span></span><br></pre></td></tr></table></figure></p>
<p>类通过<code>extends</code>关键字进行继承。<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    constructor(name,age,sex,school)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age,school);</span><br><span class="line">        <span class="keyword">this</span>.school = school;</span><br><span class="line">    &#125;</span><br><span class="line">    getInfo()&#123;</span><br><span class="line">        <span class="keyword">super</span>.getInfo();</span><br><span class="line">        console.log(<span class="keyword">this</span>.school);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>super</code>关键字是用来继承新建父类的<code>this</code>对象，因为子类没有自己的<code>this</code>对象，新建实例的时候会报错。使用<code>super</code>之后，可继承父类的<code>this</code>对象。<br>ES6提出的类实现继承，比ES5通过原型链实现继承要清晰，可以让我们写出更加简洁的代码。</p>
<hr>
<h2 id="7-Symbols"><a href="#7-Symbols" class="headerlink" title="7.Symbols"></a><span id="symbols">7.Symbols</span></h2><p><code>symbols</code>是ES6新增的第七种原始数据类型，表示独一无二的值。简单来说，就是用来做标记的方法。<br>用法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a)           <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，通过<code>typeof</code>得出<code>a</code>是<code>symbol</code>数据类型。<br><code>symbol</code>创造出来的符号是独一无二的，因此设置了相同参数<code>symbol</code>函数的返回值是不想等的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>());                     <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">"a"</span>) === <span class="built_in">Symbol</span>(<span class="string">"a"</span>))                <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<p><code>symbol</code>可以用于对象的属性名，由于每个<code>symbol</code>值都是不相等的，所以就可以用来作为标记，就可以保证不会出现相同的属性。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[a] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[a]);        <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></p>
<p>有时候会需要重新使用同一个<code>symbol</code>值，可以使用 <code>symbol.for</code>方法。这个方法会接受一个字符串作为参数，搜索有没有以该参数作为名称的<code>symbol</code>值，如果有，则返回<code>symbol</code>值，否则就新建并返回一个以该字符串为参数的<code>symbol</code>值。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">console.log(<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"a"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"a"</span>))</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，返回<code>true</code>，说明上面两个的<code>symbol</code>为同一个值。</p>
<hr>
<h2 id="8-for…of循环"><a href="#8-for…of循环" class="headerlink" title="8.for…of循环"></a><span id="for">8.for…of循环</span></h2><p><code>for...of</code>是ES6新增的遍历器。可以遍历数组、类数组对象、字符串、对象等。<br>ES6前：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])      <span class="comment">// a b c d </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES6:<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">val</span> <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    console.log(<span class="keyword">val</span>)        <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历数组可以直接获取数组值。<br><strong> entries()、keys()、values() </strong><br><code>entries()</code>、<code>keys()</code>、<code>values()</code>用来遍历数组。<br><code>entries()</code>是对键值对的遍历。<br><code>keys()</code>是对键名的遍历。<br><code>values()</code>是对键值的遍历。<br><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">val</span> <span class="keyword">of</span> arr.keys())&#123;</span><br><span class="line">    console.log(<span class="keyword">val</span>);  <span class="comment">// 0,1,2,3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> <span class="keyword">val</span> <span class="keyword">of</span> arr.values())&#123;</span><br><span class="line">    console.log(<span class="keyword">val</span>);      <span class="comment">// a,b,c,d</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [i,<span class="keyword">val</span>] <span class="keyword">of</span> arr.entries())&#123;</span><br><span class="line">    console.log(i,<span class="keyword">val</span>);         <span class="comment">//  0 "a"</span></span><br><span class="line">                                <span class="comment">//  1 "b"</span></span><br><span class="line">                                <span class="comment">//  2 "c"</span></span><br><span class="line">                                <span class="comment">//  3 "d"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="9-Set和Map数据解构"><a href="#9-Set和Map数据解构" class="headerlink" title="9.Set和Map数据解构"></a><span id="setAndMap">9.Set和Map数据解构</span></h2><p><strong> set和WeakSet </strong><br>ES6增添了新的数据结构集<code>set</code>和弱集<code>weakset</code>，类似于数组，但是<code>set</code>和<code>weakset</code>具有元素的唯一性，若添加了已存在的元素，会被自动忽略。<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">set</span> = new <span class="comment">Set()</span>;</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">"hello"</span>).add(<span class="string">"world"</span>).add(<span class="string">"hello"</span>);</span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>.size);          <span class="comment">// 2</span></span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>);           <span class="comment">// Set &#123;"hello", "world"&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>由于具有元素的唯一性，所以可以利用<code>set</code>来除去数组重复的元素。<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">let arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>];</span><br><span class="line">arr = Array.from(new Set(arr));</span><br><span class="line">console.log(arr);       <span class="comment">//[2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>的属性：<br><code>size</code>：用来获取<code>set</code>实例的元素个数。<br><code>set</code>的方法有四个：<br><code>add</code>：添加实例元素。<br><code>delete</code>：删除某个元素。<br><code>has</code>：判断某个元素是否存在。<br><code>clear</code>：清除所有元素。<br><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">set</span> = new <span class="comment">Set()</span>;</span><br><span class="line"><span class="keyword">set</span>.add(<span class="string">"hello"</span>).add(<span class="string">"world"</span>).add(<span class="string">"hello"</span>);</span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>.size);          <span class="comment">// 2</span></span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>);           <span class="comment">// Set &#123;"hello", "world"&#125;</span></span><br><span class="line"></span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>.has(<span class="string">"world"</span>));          <span class="comment">// ture</span></span><br><span class="line"><span class="keyword">set</span>.delete(<span class="string">"world"</span>);</span><br><span class="line">console.<span class="built-in">log</span>(<span class="keyword">set</span>.has(<span class="string">"world"</span>));          <span class="comment">//false</span></span><br><span class="line"><span class="keyword">set</span>.clear()</span><br><span class="line">console.log(<span class="keyword">set</span>);       <span class="comment">//Set &#123;&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><code>weakset</code>是弱集，与<code>set</code>相比，它能够检查元素的变量引用情况，如果元素的引用已被全部解除，则该元素就会删除，可以节省空间内存。另外，<code>weakset</code>的成员只能是对象。<br><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">let weakset = <span class="keyword">new</span> WeakSet();</span><br><span class="line">weakset.<span class="built_in">add</span>(<span class="string">"hello"</span>);           <span class="comment">// TypeError: Invalid value used in weak set</span></span><br><span class="line"></span><br><span class="line">let <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"hello"</span>);</span><br><span class="line">weakset.<span class="built_in">add</span>(<span class="built_in">str</span>);</span><br><span class="line">console.<span class="built_in">log</span>(weakset.has(<span class="built_in">str</span>));           <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong> map和weakmap </strong><br><code>map</code>和<code>weakmap</code>则与原本的<code>object</code>相似，都是<code>key/value</code>的键值对结构，但是<code>object</code>的<code>key</code>值必须是字符串或数字，而<code>map</code>可以使用任何对象作为<code>key</code>值。<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123; name : <span class="string">"dudu"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(obj,<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'hello'</span>,<span class="string">'world'</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>);  <span class="comment">//Map &#123;Object &#123;name: "dudu"&#125; =&gt; "hello", "hello" =&gt; "world"&#125;</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>.size);           <span class="comment">//2</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>.has(obj));       <span class="comment">// true</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>.get(<span class="string">"hello"</span>));  <span class="comment">// world</span></span><br></pre></td></tr></table></figure></p>
<p><code>set</code>的属性和方法：<br><code>size</code>：用来获取<code>map</code>实例的元素个数。<br><code>set</code>：用来设置<code>key</code>对应的键值。<br><code>get</code>：用来获取<code>key</code>对应的键值。<br><code>delete</code>：删除某个键。<br><code>has</code>：判断某个键是否存在。<br><code>clear</code>：清除所有键。<br><code>weakmap</code>和<code>weakset</code>相似，但是<code>weakmap</code>会检查键和值，只要其中一个的引用全被解除，则该键值对就会被删除。<br><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123; name : <span class="string">"dudu"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(obj,<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'hello'</span>,<span class="string">'world'</span>);</span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>.has(obj));      <span class="comment">//true</span></span><br><span class="line">obj = <span class="built_in">null</span>; </span><br><span class="line">console.<span class="keyword">log</span>(<span class="built_in">map</span>.has(obj));      <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="10-promise"><a href="#10-promise" class="headerlink" title="10.promise"></a><span id="promise">10.promise</span></h2><p>ES6新添的<code>promise</code>是可以用来解决回调函数无限嵌套的工具，也就是可以获取异步操作的消息，进行相应的处理。<br><code>promise</code>的状态变化有两种：从<code>pending</code>未完成到<code>resolved</code>成功和<code>pending</code>未完成到<code>rejected</code>失败，一旦这两个状态任一发生了，就会进行下一步操作。<br>用法：<br>（1）创建一个promise实例，参数为一个函数，向该函数的传入两个参数分别为<code>resolve</code>和<code>reject</code>。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/*成功*/</span>)&#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>resolve</code>函数是当<code>promise</code>对象的状态从<code>pending</code>未完成到<code>resolved</code>成功时，进行的异步操作。<br><code>reject</code>函数是当<code>promise</code>对象的状态从<code>pending</code>未完成到<code>rejected</code>失败时，进行的异步操作。<br>（2）当<code>promise</code>实例创建好之后，则用<code>then</code>方法分别指定<code>resolve</code>和<code>reject</code>状态的毁掉函数。<br><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span>&#123;</span></span><br><span class="line">    <span class="comment">//成功</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></span><br><span class="line">    <span class="comment">//失败</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><code>then</code>方法中，参入两个函数作为参数，第一个参数是<code>promise</code>对象的状态变成成功<code>resolve</code>时执行的回调函数。第二个参数是<code>promise</code>对象的状态报错<code>reject</code>时执行的回调函数。<br>也可以通过<code>catch</code>方法进行<code>reject</code>状态的回调函数。<br><figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span>&#123;</span></span><br><span class="line">    <span class="comment">//成功</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span>&#123;</span></span><br><span class="line">    <span class="comment">//失败</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当<code>promise</code>对象的状态变成<code>resolve</code>时，则执行<code>then</code>方法，当<code>promise</code>对象的状态变成<code>reject</code>时，则执行<code>catch</code>方法。</p>
<p>异步加载图片实例：<br><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(image);</span><br><span class="line">        &#125;;</span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'could not load image at '</span> + <span class="built_in">url</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = <span class="built_in">url</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadImageAsync(<span class="string">'./images/1.png'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">image</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//success</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//failure</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="11-Generators生成器"><a href="#11-Generators生成器" class="headerlink" title="11.Generators生成器"></a><span id="generators">11.Generators生成器</span></h2><p>ES6提供的<code>Generators</code>函数是一种异步编程解决方案，本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。与普通函数相比，<code>Generators</code>有两个不同点：1.定义<code>Generators</code>函数需要在<code>function</code>与函数名之间插入<code>*</code>；2、在函数内部，使用<code>yield</code>语句来切出返回值。<br><code>yield</code>与<code>return</code>相似，但是<code>yield</code>不退出函数，只是在函数运行过程中，通过<code>.next()</code>切出一个值。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloworld</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>斐波那契数列例子：<br>(斐波那契数列：从第三项开始，值为前两项之和，第一二项都为1)<br>(1)构建生成器<br><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">function</span>* Fibo()&#123;</span><br><span class="line">    let [a,<span class="keyword">b] </span>= [<span class="number">1</span>,<span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">    <span class="keyword">yield </span>a<span class="comment">;</span></span><br><span class="line">    <span class="keyword">yield </span><span class="keyword">b;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">while</span>(true)&#123;</span><br><span class="line">        [a,<span class="keyword">b] </span>= [<span class="keyword">b,a+b];</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">yield </span><span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)启动生成器<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let fibo</span> = Fibo();</span><br></pre></td></tr></table></figure></p>
<p>(3)运行生成器<br>输出前十项斐波那契数：<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    arr.<span class="keyword">push</span>(fibo.next().value);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(arr);   <span class="comment">//[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span></span><br></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/2017/04/18/基于react-nodejs-mongodb-webpack-redux实现图片上传应用/" class="prev">PRVE</a><a href="/2016/09/09/使用webpack进行es6开发/" class="next">NEXT</a></div><div data-thread-key="2016/09/15/讲讲es6那些事/" data-title="讲讲ECMAScript 6那些事" data-url="http://zengzoe.github.io/2016/09/15/讲讲es6那些事/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"zengzoe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2018 <a href="http://zengzoe.github.io">Zeng Zoe</a>, unless otherwise noted.</p><p style="display:none !important;"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span id="busuanzi_container_site_uv">本站总访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>