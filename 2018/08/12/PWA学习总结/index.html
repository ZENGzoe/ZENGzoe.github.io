<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PWA学习总结 · 曾洁仪博客</title><meta name="description" content="PWA学习总结 - Zeng Zoe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="css/googleapisFonts.css" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/zengjieyi1994" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/ZENGzoe" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><span style="display:none !important;"><span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span></span></span><article class="post-block"><h1 class="post-title">PWA学习总结</h1><div class="post-time">2018年8月12日</div><div class="post-content"><p><img src="/2018/08/12/PWA学习总结/pwa.jpg" alt=""></p>
<p><a href="#一、PWA是什么">一、PWA是什么</a><br><a href="#二、PWA的技术">二、PWA的技术</a><br><a href="#三、添加至桌面">三、添加至桌面</a><br><a href="#四、离线缓存">四、离线缓存</a><br><a href="#五、消息推送和提醒">五、消息推送和提醒</a><br><a href="#六、后台数据同步">六、后台数据同步</a><br><a href="#七、总结">七、总结</a><br><a href="#八、参考文档">参考文档</a></p>
<p>demo:新闻搜索demo <a href="https://github.com/ZENGzoe/pwa-exercise/tree/master" target="_blank" rel="noopener">(https://github.com/ZENGzoe/pwa-exercise/tree/master)</a></p>
<h1 id="一、PWA是什么"><a href="#一、PWA是什么" class="headerlink" title="一、PWA是什么"></a>一、PWA是什么</h1><p>PWA（Progress Web Apps）即渐进式网页应用，可以让用户在使用web页面的时候如同使用App，大大的提升了web页面的性能和体验。</p>
<p><br></p>
<h1 id="二、PWA的技术"><a href="#二、PWA的技术" class="headerlink" title="二、PWA的技术"></a>二、PWA的技术</h1><p>PWA不是一项技术，而是一系列技术的集合。<br><img src="/2018/08/12/PWA学习总结/technolodgeLink.png" alt=""><br>从上图可以看出，PWA中一系列的技术包括了Service worker、Manifest、Push、Notification、Sync等，其中Service worker技术较强大，大部分的功能都要基于它实现。</p>
<p>PWA可以实现添加至桌面、离线缓存、消息推送和提醒、后台同步数据等功能，使得web应用更加接近原生App。</p>
<p><br></p>
<h1 id="三、添加至桌面"><a href="#三、添加至桌面" class="headerlink" title="三、添加至桌面"></a>三、添加至桌面</h1><p>将web应用添加至桌面，启动时，可实现主屏幕即打开的原生app体验。</p>
<p>PWA中实现添加至桌面的功能通过,Manifest实现，通过一个json文件，就可配置web应用添加至桌面的标题、icon、描述、展示模式等。</p>
<p><br></p>
<h5 id="3-1-配置manifest-json"><a href="#3-1-配置manifest-json" class="headerlink" title="3.1. 配置manifest.json"></a>3.1. 配置manifest.json</h5><p>以下为manifest.json例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"新闻搜索"</span>,</span><br><span class="line">    <span class="attr">"short_name"</span> : <span class="string">"news"</span>,</span><br><span class="line">    <span class="attr">"start_url"</span> : <span class="string">"/"</span>,</span><br><span class="line">    <span class="attr">"display"</span> : <span class="string">"standalone"</span>,       </span><br><span class="line">    <span class="attr">"background_color"</span> : <span class="string">"#02cfd4"</span>,</span><br><span class="line">    <span class="attr">"description"</span> : <span class="string">"可以用于新闻搜索的小应用"</span>,</span><br><span class="line">    <span class="attr">"theme_color"</span> : <span class="string">"#02cfd4"</span>,</span><br><span class="line">    <span class="attr">"orientation"</span> : <span class="string">"portrait-primary"</span>,</span><br><span class="line">    <span class="attr">"icons"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_32.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"32x32"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_72.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"72x72"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_128.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"128x128"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_144.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"144x144"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_192.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"192x192"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_256.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"256x256"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">"src"</span> : <span class="string">"img/icon_512.png"</span>,</span><br><span class="line">            <span class="attr">"sizes"</span> : <span class="string">"512x512"</span>,</span><br><span class="line">            <span class="attr">"type"</span> : <span class="string">"image/png"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置解释：</p>
<p><code>name</code> : 打开桌面web应用时，启动页的标题<br><code>short_name</code> : 添加至桌面应用的名称<br><code>start_url</code> : 桌面应用打开的地址，如设置为’/‘，为manifest.json当前路径的index.html<br><code>display</code> : 桌面应用打开后展示的模式，有四种模式：fullscreen、standalone、minimal-ui、browser<br>    -<code>fullscreen</code>模式 : 页面占满整个屏幕<br>    -<code>standalone</code>模式 : 此模式比较相似在app打开，与全屏模式相比，展示手机屏幕顶部信息时间、电量等信息栏。<br>    -<code>minimal-ui</code>模式 : 与standalone模式相比，多出浏览器地址栏<br>    -<code>browser</code>模式 : 浏览器模式，与浏览器打开一致</p>
<p><img src="/2018/08/12/PWA学习总结/display.jpg" alt=""></p>
<p>其中，部分Android手机Chrome浏览器能够兼容四种模式，部分Android手机Chrome浏览器目前只兼容standalone和browser模式，fullscreen和minimal-ui则向下兼容为standalone和browser模式。</p>
<p><code>background_color</code> : 启动页背景颜色<br><code>description</code> : web应用描述<br><code>theme_color</code> : 打开桌面应用，地址栏、信息栏主题颜色,可看上图的standalone和minimal-ui模式<br><code>orientation</code> : 指定页面的展示方向，会根据不同设备横竖屏的角度去定义。<br>    -<code>portrait</code>｜<code>portrait-primary</code>｜<code>portrait-secondary</code> : 竖屏<br>    -<code>portrait</code>｜<code>portrait-primary</code>｜<code>portrait-seconday</code> : 横屏<br>    -<code>natural</code> :  设备屏幕旋转角度为0° 对应的方向<br>    -<code>any</code> : 可根据设备屏幕角度旋转页面<br><code>icons</code> : 桌面应用icon图、开启页展示图，数组格式，浏览器会选择适合的尺寸作为icon图<br>    -<code>src</code> : icon地址<br>    -<code>sizes</code> : icon尺寸，单位为px，格式为宽x高<br>    -<code>type</code> : icon格式，如png为image/png、jpg为image/jpg、jpeg为image/jpeg</p>
<p><br></p>
<h5 id="3-2-引入manifest-json"><a href="#3-2-引入manifest-json" class="headerlink" title="3.2. 引入manifest.json"></a>3.2. 引入manifest.json</h5><p>配置完manifest.json后，在index.html中链入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只需要以上两步，就可以实现页面添加至桌面的功能。</p>
<p><br></p>
<h5 id="3-3-兼容性"><a href="#3-3-兼容性" class="headerlink" title="3.3. 兼容性"></a>3.3. 兼容性</h5><p>Manifest兼容性可以在<a href="https://caniuse.com/#search=manifest" target="_blank" rel="noopener">caniuse.com</a>查看：<br><img src="/2018/08/12/PWA学习总结/manifestCompatibility.png" alt=""></p>
<p>目前Android的Chrome浏览器和UC支持Manifest，而iOS要在11.4以上版本才支持。</p>
<p><br></p>
<h1 id="四、离线缓存"><a href="#四、离线缓存" class="headerlink" title="四、离线缓存"></a>四、离线缓存</h1><p>缓存web的资源，当用户再次访问页面时，可以优先从缓存中读取数据渲染页面，提升访问速度。在无网络的环境下，也可以继续访问web页面。比如当缓存了h5小游戏，可随时随地离线刷游戏。实现离线缓存，需要Service Worker和Cache API的结合。</p>
<p><br></p>
<h4 id="4-1-Service-Worker介绍"><a href="#4-1-Service-Worker介绍" class="headerlink" title="4.1. Service Worker介绍"></a>4.1. Service Worker介绍</h4><p>Service Worker：服务工作线程，是浏览器在后台独立于网页运行的脚本。因此Service Worker的运行不会阻塞js脚本的运行。除了可以实现离线缓存，Service Worker在消息推送、后台同步等功能中都扮演着重要的角色，详细的api将会随着余下章节介绍。</p>
<p>使用Service Worker，可以拦截请求，具有一定的安全性问题，因此项目部署发布时，Service Worker只能HTTPS域下内使用。为了方便开发调试，规定还可在<code>localhost</code>或<code>127.0.0.1</code>下使用。</p>
<p>Service Worker有自己的生命周期，当在Javascript注册Service Worker后，Service Worker的生命周期开始。</p>
<p>Service Worker生命周期：installing（安装中） -&gt; installed（安装后） -&gt; activating（激活中） -&gt; activated（激活后） -&gt; redunbant（无用）。</p>
<p><strong>installing阶段：</strong> 通常用来缓存资源。</p>
<p><code>event.waitUntil()</code> : 参数为一个promise，在该promise中进行资源的缓存，缓存资源成功则安装成功，缓存资源失败则安装失败。</p>
<p><code>self.skipWaiting()</code> : 可跳过安装等待阶段，直接进入激活阶段，加快工作进程。</p>
<p><strong>installed阶段：</strong> 表示Service Worker安装成功。</p>
<p><strong>activating阶段：</strong> 通常用来清除旧缓存。</p>
<p><code>event.waitUntil()</code> : 参数为一个promise，在该promise中清除旧缓存。</p>
<p><code>self.client.claim()</code> : 控制未受控制的客户端。默认情况下，安装Service Worker之后，需要刷新页面才能有Service Worker系列操作，执行该方法，可改变该默认情况，无需重新刷新页面。</p>
<p><strong>activated阶段：</strong> 表示Service Worker可以控制客户端。</p>
<p><strong>redunbant阶段：</strong> 无用阶段。当Service Worker install失败、activate失败或有新的Service Worker代替，则Service Worker变为redunbant。</p>
<p><img src="/2018/08/12/PWA学习总结/workerLifecycle.png" alt=""></p>
<p><br></p>
<h4 id="4-2-Cache-API介绍"><a href="#4-2-Cache-API介绍" class="headerlink" title="4.2. Cache API介绍"></a>4.2. Cache API介绍</h4><p>caches是window的属性之一，用于缓存静态资源或请求返回的数据。</p>
<p>主要的缓存数据来源：<br>1.Service Sorker的install事件中缓存静态资源，比如缓存html、css、js等静态资源<br>2.Service Worker的fetch事件中缓存请求的数据<br>3.用户交互请求的数据，比如查看某些图片、视频等</p>
<p>使用caches之前，需要判断浏览器是否支持：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="comment">//支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Caches API：</strong></p>
<p>1.创建或打开cache</p>
<p>如果缓存中存在cacheName则直接打开，不存在则创建新的cacheName。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">caches.<span class="built_in">open</span>(cacheName)  <span class="comment">//自定义cacheName</span></span><br></pre></td></tr></table></figure>
<p>返回一个promise，对cacheName的存储、删除等操作需要在返回的promise中进行。</p>
<p>2.缓存数据</p>
<p>（1）<code>add(url)</code>：缓存单个静态数据，参数为静态数据路径。路径错误，则缓存失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">caches.open(cacheName).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">    cache.add(<span class="string">'./index.js'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>（2）<code>allAll(urlArray)</code>：缓存多个静态数据，参数为静态数据路径的数组。如果数组中某一项的路径错误，整个数组的静态数据缓存失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">caches.open(cacheName).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">    cache.add([</span><br><span class="line">        <span class="string">'/'</span>,</span><br><span class="line">        <span class="string">'./index.html'</span>,</span><br><span class="line">        <span class="string">'./js/index.js'</span>,</span><br><span class="line">        <span class="string">'./css/index.css'</span>,</span><br><span class="line">    ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>（3）<code>put(request,response)</code>：缓存请求的数据，第一个参数为请求的url，第二个参数为请求返回数据。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(url)</span></span>.then(response =&gt; &#123;</span><br><span class="line">    cache.put(url,response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3.查找缓存</p>
<p>缓存的查找是根据cacheName中的请求进行查找。</p>
<p>（1）<code>match(request,options)</code> : 查找第一个匹配的缓存。</p>
<p>第一个参数为需要匹配的请求，第二个参数为请求的过滤：</p>
<p><code>ignoreSearch</code> ：Boolean值，默认值为false，当设置为true，则过滤掉hash，如请求为<code>http://xxx.com?q=xxx</code>将会被过滤掉。<br><code>ignoreMethod</code> ：Boolean值，默认值为false，当设置为true，则阻止对request请求的http方法的验证（通常只允许GET和HEAD两种请求方法）。<br><code>ignoreVary</code> ：Boolean值，默认值为false，当设置为true，则忽略对VARY头信息的匹配。如当请求的request匹配成功，对与获取的response值，不会进行VARY头信息的匹配。<br><code>cacheName</code> ：缓存名，一般忽略。</p>
<p>如果不匹配，则返回undefined。匹配成功，则返回带有reponse的promise。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">caches.<span class="built_in">open</span>(cacheName).<span class="keyword">then</span>(cache =&gt; &#123;</span><br><span class="line">    cache.<span class="built_in">match</span>(<span class="string">'./index.js'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span>&#123;</span><br><span class="line">        //response为返回结果</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>（2）<code>matchAll(request,options)</code> ：查找全部匹配的缓存。参数和返回结果同<code>match</code>。</p>
<p>4.删除缓存 </p>
<p><code>delete(key)</code> : 删除流程为找到匹配的缓存并删除，返回的结果为promise。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">caches.<span class="built_in">open</span>(cacheName).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(cache)</span></span> &#123;</span><br><span class="line">  cache.matchAll(<span class="string">'./images/'</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(response)</span></span> &#123;</span><br><span class="line">    response.forEach(<span class="function"><span class="keyword">function</span><span class="params">(element, index, array)</span></span> &#123;</span><br><span class="line">      cache.delete(element);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>5.遍历缓存</p>
<p>遍历所有的缓存,参数同match，非必参，当为传入参数，则返回所有的缓存。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">caches.<span class="built_in">keys</span>(request,options).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span>(<span class="title">keys</span>)&#123;</span></span><br><span class="line">   <span class="comment"> //返回的keys为数组</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-3-离线缓存实践"><a href="#4-3-离线缓存实践" class="headerlink" title="4.3. 离线缓存实践"></a>4.3. 离线缓存实践</h4><p>Service Worker可以监听web发出的请求，同时作为代理，向服务器发起请求，并判断是否需要使用缓存作为web的请求返回。</p>
<p><img src="/2018/08/12/PWA学习总结/cachePro.png" alt=""></p>
<p>如果缓存中存在请求的数据，则Service Worker不发起请求，直接返回缓存。如果缓存中不存在请求的数据，则Service Worker代理发起请求，缓存数据，并返回浏览器数据。</p>
<p><br></p>
<h5 id="4-3-1-注册Service-worker"><a href="#4-3-1-注册Service-worker" class="headerlink" title="4.3.1. 注册Service worker"></a>4.3.1. 注册Service worker</h5><p>使用Service Worker第一步，创建serviceWorker.js，并在js中注册Service Worker</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//判断是否支持serviceWorker</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)&#123;</span><br><span class="line">    <span class="comment">//serviceWorker.js后缀为随机戳，方便更新serviceWorker.js</span></span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./serviceWorker.js'</span>, &#123; <span class="attr">scope</span> : <span class="string">'/'</span>&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service worker注册成功'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>navigator.serviceWorker.register(url,scope)</code>注册Service Worker，第一个参数为<code>serviceWorker.js</code>的地址，第二个参数<code>scope</code>为缓存文件的范围，最大范围是<code>serviceWorker.js</code>所在的当前目录，范围的设定只能为<code>serviceWorker.js</code>同目录或子目录，比如<code>serviceWorker.js</code>的路径为<code>app/public/</code>，子文件有<code>img</code>，范围可以设定为同目录<code>/</code>或子目录<code>/img/</code>，不能设为<code>app/static/</code>等非同目录和子目录，因此需要将<code>serviceWorker.js</code>放在需要缓存的文件的最外层路径里。当第二个参数为空时，默认是范围是同目录范围，即<code>/</code>。</p>
<p><br></p>
<h5 id="4-3-2-缓存静态资源"><a href="#4-3-2-缓存静态资源" class="headerlink" title="4.3.2. 缓存静态资源"></a>4.3.2. 缓存静态资源</h5><p>1.缓存静态数据，在install事件中缓存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceWorker.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cacheName = <span class="string">'news-v1'</span>,  <span class="comment">//唯一的缓存名</span></span><br><span class="line">    cacheFiles = [          <span class="comment">//需要缓存的静态文件地址</span></span><br><span class="line">        <span class="string">'/'</span>,</span><br><span class="line">        <span class="string">'./index.html'</span>,</span><br><span class="line">        <span class="string">'./js/index.js'</span>,</span><br><span class="line">        <span class="string">'./css/index.css'</span>,</span><br><span class="line">        <span class="string">'./img/white.jpg'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听service worker安装事件，在install事件中缓存静态文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'install'</span>);</span><br><span class="line">    <span class="comment">//在安装前执行</span></span><br><span class="line">    e.waitUntil(</span><br><span class="line">        <span class="comment">//存储</span></span><br><span class="line">        caches.open(cacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.addAll(cacheFiles);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>2.使用缓存的静态文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//监听客户端所有的请求</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    e.respondWith(</span><br><span class="line">        caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//如果缓存中有匹配的请求，返回缓存的静态资源</span></span><br><span class="line">            <span class="keyword">return</span> cache || fetch(e.request)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//没有缓存</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'err'</span>,err);</span><br><span class="line">            <span class="keyword">return</span> fetch(e.request)</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>添加上面的代码后，就可以在离线的状态下继续访问页面。</p>
<p><br></p>
<h5 id="4-3-3-缓存API请求"><a href="#4-3-3-缓存API请求" class="headerlink" title="4.3.3. 缓存API请求"></a>4.3.3. 缓存API请求</h5><p>除了静态资源，还可以缓存动态请求的数据，动态请求的数据与静态数据的差异在于如果本地缓存中有请求的缓存，在服务器请求未返回前使用缓存的数据，服务器请求返回后，更新数据。</p>
<p>在demo中的缓存搜索新闻的请求：</p>
<p>1.缓存搜索api的数据</p>
<p>在fetch事件中缓存动态请求的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceWorker.js</span></span><br><span class="line"><span class="keyword">var</span> fetchCacheName = <span class="string">'news-api-v1'</span>, <span class="comment">//唯一的缓存名</span></span><br><span class="line">    cacheFetchUrls = [      <span class="comment">//缓存的api</span></span><br><span class="line">        <span class="string">'/news?'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断请求是否需要缓存</span></span><br><span class="line">    <span class="keyword">var</span> needCache = cacheFetchUrls.some(<span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.request.url.indexOf(url) &gt; <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(needCache)&#123;</span><br><span class="line">        caches.open(fetchCacheName).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> fetch(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//缓存请求</span></span><br><span class="line">                <span class="keyword">if</span>(response.statusText !== <span class="string">'Not Found'</span>)&#123;</span><br><span class="line">                    cache.put(e.request.url,response.clone())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>由于内存效率问题，请求的response流只能读一次，如果直接执行<code>cache.put(request, response)</code>将response流存入内存中，将不能返回给浏览器，因此需要将response复制再存储。详细介绍可参考<a href="https://jakearchibald.com/2014/reading-responses/" target="_blank" rel="noopener">What happens when you read a response?</a></p>
<p>2.从缓存中读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">getDataFromCache : <span class="function"><span class="keyword">function</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'caches'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> caches.match(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cache || cache.responseText == <span class="string">'Not Found'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果缓存中有匹配的请求，返回数据</span></span><br><span class="line">            <span class="keyword">return</span> cache.json();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>封装从缓存中搜索匹配的请求，如匹配成功，返回缓存的数据。</p>
<p>3.请求数据</p>
<p>请求数据，当数据未返回时，优先展示缓存中的数据，数据返回后，当新数据和缓存数据不同时，重新更新数据，并缓存新数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">queryNews : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>,</span><br><span class="line">        newsName = <span class="built_in">document</span>.querySelector(<span class="string">'#input'</span>).value;</span><br><span class="line">        url = <span class="string">'/news?q='</span> + newsName;    <span class="comment">//搜索新闻接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(newsName === <span class="string">''</span>)&#123;</span><br><span class="line">        alert(<span class="string">'请输入想要了解的新闻'</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fetchData = _this.fetchNewsApi(url);        <span class="comment">//fetch搜索新闻接口</span></span><br><span class="line">    <span class="keyword">var</span> cacheData;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缓存中匹配请求</span></span><br><span class="line">    _this.getDataFromCache(url).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(data &amp;&amp; data.data &amp;&amp;  data.data.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            _this.fillNews(data.data)</span><br><span class="line">        &#125;</span><br><span class="line">        cacheData = data || &#123;&#125;;</span><br><span class="line">        <span class="keyword">return</span> fetchData;</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//请求成功，重新渲染数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">JSON</span>.stringify(data) !== <span class="built_in">JSON</span>.stringify(cacheData))&#123;</span><br><span class="line">            _this.fillNews(data.data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当断网后，就可以继续搜索同样的新闻～</p>
<p><br></p>
<h5 id="4-3-4-更新缓存"><a href="#4-3-4-更新缓存" class="headerlink" title="4.3.4. 更新缓存"></a>4.3.4. 更新缓存</h5><p>当修改代码时，需要客户端更新数据，可通过两种方法：</p>
<p>1.url加时间戳或随机数戳</p>
<p>如注册Service Worker中serviceworker.js后面添加的戳</p>
<p>2.修改cacheName，并删除无用的cacheName</p>
<p>在activate事件中删除无用缓存</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceWorker.js</span></span><br><span class="line"><span class="comment">//监听激活事件，删除无用的缓存</span></span><br><span class="line"><span class="keyword">self</span>.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在激活前之行</span></span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.keys().then(<span class="function"><span class="keyword">function</span><span class="params">(keys)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Promise().all(keys.map(<span class="function"><span class="keyword">function</span><span class="params">(key)</span></span>&#123;</span><br><span class="line">                <span class="comment">//通过修改cacheName来更新缓存，并删掉无用缓存</span></span><br><span class="line">                <span class="keyword">if</span>(key !== cacheName)&#123;</span><br><span class="line">                    <span class="keyword">return</span> caches.delete(key)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.clients.claim();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<h4 id="4-3-兼容性"><a href="#4-3-兼容性" class="headerlink" title="4.3. 兼容性"></a>4.3. 兼容性</h4><p>从caniuse中查看<a href="https://caniuse.com/#search=service%20workers" target="_blank" rel="noopener">Service Worker</a>的兼容性：</p>
<p><img src="/2018/08/12/PWA学习总结/serviceworkeruse.png" alt=""></p>
<p>大部分主流浏览器支持Service Worker，苹果从ios11.4的系统版本中也开始支持Service Worker。</p>
<p><br></p>
<h1 id="五、消息推送和提醒"><a href="#五、消息推送和提醒" class="headerlink" title="五、消息推送和提醒"></a>五、消息推送和提醒</h1><p>消息推送和提醒可以说是App常规的功能，在自己的web应用中加入消息推送和提醒功能，可以让我们的页面更接近APP。消息推送和提醒的技术实现基于Service Worker，因此在页面没有打开的情况下也能消息提醒进行操作。</p>
<p>消息推送和提醒使用不同的API实现，分别是push API和notification API，push可以让服务器发送消息给Service Worker，notification可以给用户显示提醒信息。</p>
<p><br></p>
<h4 id="5-1-Push"><a href="#5-1-Push" class="headerlink" title="5.1. Push"></a>5.1. Push</h4><p>消息推送流程比较复杂，在消息推送过程中还需要保证传递的信息的安全性，具体内容请往下看。</p>
<p><br></p>
<h5 id="5-1-1-推送消息的三个流程"><a href="#5-1-1-推送消息的三个流程" class="headerlink" title="5.1.1. 推送消息的三个流程"></a>5.1.1. 推送消息的三个流程</h5><p>在开始使用push API之前，需要了解消息推送的工作流程。主要由三个部分组成：</p>
<p>1.客户端订阅消息推送<br>2.服务器端推送消息给浏览器<br>3.Service Worker接收消息</p>
<p>下面是关于这三部分的详细介绍。</p>
<p><br></p>
<h5 id="5-1-2-客户端订阅消息推送"><a href="#5-1-2-客户端订阅消息推送" class="headerlink" title="5.1.2. 客户端订阅消息推送"></a>5.1.2. 客户端订阅消息推送</h5><p>消息推送的第一步是订阅，订阅又分为三部分：</p>
<p>（1）向用户请求消息推送<br>（2）向push service发送订阅消息<br>（3）将PushSubscription发送至服务器</p>
<p><img src="/2018/08/12/PWA学习总结/pushprocess.png" alt=""></p>
<p><br></p>
<p><strong>（1）向用户请求消息推送：</strong></p>
<p>通过向用户弹出推送请求弹窗向用户请求：</p>
<p><img src="/2018/08/12/PWA学习总结/access.png" alt=""></p>
<p>实现方法通过<code>Notification.requestPermission()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">askPermission</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> permissionResult = Notification.requestPermission(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//旧版本</span></span><br><span class="line">            resolve(result);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span>(permissionResult)&#123;</span><br><span class="line">            <span class="comment">//新版本</span></span><br><span class="line">            permissionResult.then(resolve , reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">permissionResult</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(permissionResult !== <span class="string">'granted'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'We weren\'t granted permission.'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的语法会返回一个promise处理请求结果，旧版本则通过回调函数处理，因此需要同时处理这两种情况。</p>
<p><code>permissionResult</code>返回结果有三种，<code>granted</code>、<code>denied</code>、<code>default</code>，<code>granted</code>为允许，<code>denied</code>为禁止，<code>default</code>为默认浏览器处理结果。</p>
<p>在注册Service Worker成功后进行推送的请求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js </span></span><br><span class="line"><span class="comment">//在使用之前还需判断是否支持PushManager</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./serviceWorker.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">            registration,</span><br><span class="line">            askPermission()</span><br><span class="line">        ])</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上上面的代码之后，刷新页面就会出现推送请求的弹窗：</p>
<p><img src="/2018/08/12/PWA学习总结/access.png" alt=""></p>
<p>当用户点击之后，无论用户选择什么，浏览器后记住用户的操作，再次访问时，不会再弹出该窗口，即该窗口指出现一次。</p>
<p><br></p>
<p><strong>（2）向push service发送订阅消息</strong></p>
<p>应用服务钥匙有一个公钥和一个私钥，私钥用于服务器，公钥用于push service。在订阅消息时，需要将公钥发送给push service。push service创建<code>endpoint</code>传递给浏览器，浏览器将<code>endpoint</code>加到<code>PushScription</code>，通过<code>subsribe()</code>的<code>promise</code>返回，这就是发送订阅消息的过程。</p>
<p><img src="/2018/08/12/PWA学习总结/subscribeProcess.png" alt=""></p>
<p><strong>push service</strong>的功能是接收请求，验证并发送消息至指定的页面，操控消息的接收和推送。甚至在页面断网时，将会继续等待直到浏览器联网时推送消息。push service存在浏览器中，每个浏览器都会使用不同的push service，庆幸的是，push service遵循<a href="https://tools.ietf.org/html/draft-ietf-webpush-protocol-12" target="_blank" rel="noopener">Web Push Protocal</a>，使用相同的API，就可以在不同的push service通用。</p>
<p><strong>PushSubscription</strong>可作为一个用户的id信息，包含了订阅的所有信息，例如：</p>
<p><img src="/2018/08/12/PWA学习总结/pushscription.png" alt=""></p>
<p>上图中的<code>endpoint</code>中可以得出该浏览器使用的push service是<code>fcm.googleapis.com</code>，<code>eq2HeeL0Mcs...</code>是指向的用户。</p>
<p>公钥和私钥的创建可以通过<code>web-push</code>：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">npm install -g web-push</span><br><span class="line">web-push <span class="keyword">generate</span>-vapid-keys</span><br></pre></td></tr></table></figure>
<p>向push service发送订阅信息通过<code>registration.pushManager.subscribe()</code>发送，需要向<code>subscribe()</code>传入一个对象，该对象中包含<code>userVisibleOnly</code>和<code>applicationServerKey</code>。</p>
<p><strong>userVisibleOnly</strong>：boolean值，标志消息的推送通过发送消息提醒用户，还是在后台默默的发送不提醒用户。部分浏览器只支持<code>userVisibleOnly</code>为<code>true</code>，如果设置为<code>false</code>或不设置，浏览器报错。</p>
<p><img src="/2018/08/12/PWA学习总结/uservisibleerr.png" alt=""></p>
<p><strong>applicationServerKey</strong>：客户端的公钥，要求Uint8Array类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribeUserToPush</span>(<span class="params">registration , publicKey</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> subscribeOptions = &#123;</span><br><span class="line">        userVisibleOnly : <span class="literal">true</span>,</span><br><span class="line">        applicationServerKey : <span class="built_in">window</span>.urlBase64ToUint8Array(publicKey)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> registration.pushManager.subscribe(subscribeOptions).then(<span class="function"><span class="keyword">function</span>(<span class="params">pushSubscription</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'pushscription'</span> ,pushSubscription)</span><br><span class="line">        <span class="keyword">return</span> pushSubscription;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>applicationServerKey</code>要求参数是Uint8Array类型，而创建的公钥是base64类型，因此使用<code>urlBase64ToUint8Array</code>方法将base64转为Uint8Array。<code>urlBase64ToUint8Array</code>方法来自<a href="https://github.com/alienzhou/learning-pwa/blob/push/public/base64util.js" target="_blank" rel="noopener">base64util.js</a>。</p>
<p>在请求推送消息用户允许后发送订阅信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="comment">//公钥</span></span><br><span class="line">    <span class="keyword">var</span> publicKey = <span class="string">'BBP3Ni05GCu_RTb7rAkOqfFPiDQkNhcAfOAhqxpaxmuKLhF3DYTldbl3vrmfTfHSHhCBXPgKhQXexEmDLLqV1sQ'</span>;</span><br><span class="line">    </span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./serviceWorker.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">            registration,</span><br><span class="line">            askPermission()</span><br><span class="line">        ])</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> registration = result[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> subscribeUserToPush(registration,publicKey)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p><br></p>
<p><strong>（3）将PushSubscription发送至服务器</strong></p>
<p>拿到<code>PushSubscription</code>后，将<code>PushSubscription</code>发送到后台服务器，后台服务器将会存储该用户的信息，并通过<code>PushSubscription</code>来推送信息。</p>
<p>假设服务器端用Nodejs已经实现接收并存储<code>PushSubscription</code>的接口<code>/subscription</code>，具体实现可查看<a href="https://github.com/ZENGzoe/pwa-exercise/blob/master/app.js" target="_blank" rel="noopener">源码</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="comment">//将PushSubscription发送至服务器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendSubscriptionToServer</span>(<span class="params">body</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = <span class="string">'/subscription'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.timeout = <span class="number">7000</span>;</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> response = &#123;&#125;;</span><br><span class="line">            <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    response = <span class="built_in">JSON</span>.parse(xhr.responseText);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">                    response = xhr.responseText</span><br><span class="line">                &#125;</span><br><span class="line">                resolve(response)</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onabort = reject;</span><br><span class="line">        xhr.onerror = reject;</span><br><span class="line">        xhr.ontimeout = reject;</span><br><span class="line">        xhr.open(<span class="string">'POST'</span> , url , <span class="literal">true</span>);</span><br><span class="line">        xhr.setRequestHeader(<span class="string">'Content-Type'</span> , <span class="string">'application/json'</span>);</span><br><span class="line">        xhr.send(body)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获得<code>subscription</code>后发送至服务器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'PushManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./serviceWorker.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">subscription</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> body = &#123;<span class="attr">subscription</span> : subscription&#125;;</span><br><span class="line"></span><br><span class="line">        body.uniqueid = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();   <span class="comment">//为方便服务器推送消息至指定的客户端</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'uniqueid'</span> , body.uniqueid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sendSubscriptionToServer(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>给每个打开的页面都设定唯一的<code>uniqueid</code>，方便服务器对特定的客户端推送消息。</p>
<p><br></p>
<h5 id="5-1-3-服务器端推送消息给浏览器"><a href="#5-1-3-服务器端推送消息给浏览器" class="headerlink" title="5.1.3. 服务器端推送消息给浏览器"></a>5.1.3. 服务器端推送消息给浏览器</h5><p>服务器端发送消息给浏览器需要保证信息的安全性，那么这就需要公钥私钥来保证信息的安全性。上文也提到私钥用户服务器，公钥用于push service,那么公钥私钥的使用逻辑如下：</p>
<p><img src="/2018/08/12/PWA学习总结/serviceKey.png" alt=""></p>
<p>（1）服务器用私钥对验证头签名<br>（2）服务器将用私钥签名了的消息发送至对应的push service<br>（3）push service收到消息后，用公钥验证解密<br>（4）push service确认验证通过无误，告诉服务器验证通过<br>（5）push service将消息发送至正确的客户端</p>
<p>由于消息推送的流程过于复杂，较难定位出现的问题，因此推荐使用<a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">web push</a>这个库进行消息加密、格式化和触发Service Worker的<code>push</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">var</span> webpush = <span class="built_in">require</span>(<span class="string">'web-push'</span>);</span><br></pre></td></tr></table></figure>
<p>由于服务器需要使用私钥，因此需要在<code>web-push</code>设置应用服务钥匙：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先前生成的公钥和私钥</span></span><br><span class="line"><span class="keyword">var</span> vapidKeys = &#123;</span><br><span class="line">    privateKey:<span class="string">"9mHKxhF60T4iApR4f4dDKtdXL8PK5dj3TfDBAK8iufI"</span>,</span><br><span class="line">    publicKey:<span class="string">"BBP3Ni05GCu_RTb7rAkOqfFPiDQkNhcAfOAhqxpaxmuKLhF3DYTldbl3vrmfTfHSHhCBXPgKhQXexEmDLLqV1sQ"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webpush.setVapidDetails(</span><br><span class="line">    <span class="string">'mailto:563282341@qq.com'</span>,</span><br><span class="line">    vapidKeys.publicKey,</span><br><span class="line">    vapidKeys.privateKey</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><code>web push</code>要求传入发送者的邮箱，为了能够方便地联系到发送者传递有用的信息。</p>
<p>在服务器端，我们使用<code>/push</code>路由，向客户端发送消息推送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&apos;/push&apos; , koaBody() , async ctx =&gt; &#123;</span><br><span class="line">    let &#123; uniqueid , payload &#125; = ctx.request.body;</span><br><span class="line">    let list = uniqueid ? await util.find(&#123;uniqueid&#125;) : await util.findAll();   //查找指定的用户</span><br><span class="line">    let status = list.length &gt; 0 ? 0 : -1;</span><br><span class="line"></span><br><span class="line">    for(let i = 0 ; i &lt; list.length ; i++)&#123;</span><br><span class="line">        let subscription = list[i].subscription;</span><br><span class="line">        pushMessage(subscription , JSON.stringify(payload));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.response.body = &#123;</span><br><span class="line">        status</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在demo中，使用了<code>nedb</code>数据库存储用户的<code>pushSubscription</code>，详细实现代码可以查看<a href="https://github.com/ZENGzoe/pwa-exercise/blob/master/util.js" target="_blank" rel="noopener">源码</a></p>
<p>在<code>pushMessage</code>方法中使用了<code>web-push</code>的<code>sendNotification</code>方法推送消息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushMessage</span>(<span class="params">subscription , data = &#123;&#125;</span>)</span>&#123;</span><br><span class="line">    webpush.sendNotification(subscription , data , options).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'push service的相应数据'</span> , <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//410和404表示subscription过期不再有效</span></span><br><span class="line">        <span class="keyword">if</span>(err.statusCode === <span class="number">410</span> || err.statusCode === <span class="number">404</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">            <span class="keyword">return</span> util.remove(subscription)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(subscription);</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>webpush.sendNotification</code>推送消息的事件能被客户端的<code>push</code>事件捕获。</p>
<p><br></p>
<h5 id="5-1-4-Service-Worker接收消息"><a href="#5-1-4-Service-Worker接收消息" class="headerlink" title="5.1.4. Service Worker接收消息"></a>5.1.4. Service Worker接收消息</h5><p>服务器推送消息至push service，push service再推送消息给用户，因此服务器发送的消息先是被Service Worker的<code>push</code>事件捕获。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceWorker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'push'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = e.data;</span><br><span class="line">    <span class="keyword">if</span>(data)&#123;</span><br><span class="line">        self.registration.showNotification(data);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'push没有任何数据'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>self</code>指向的是<code>serviceWorker</code>，push service通过<code>self.registration.showNotification</code>方法向用户发送提醒。</p>
<p>这就是消息推送的三大流程，到这里就可以直接给用户推送消息。可以新建一个后台页面进行消息推送，也可以使用<a href="https://www.getpostman.com/" target="_blank" rel="noopener">postman</a>模拟后台推送消息。在demo中，我简单地搭了一个后台页面：</p>
<p><img src="/2018/08/12/PWA学习总结/backend.png" alt=""></p>
<p>用户id指的是打开页面时生成的uniqueid，输入用户id和要传送的消息后，点击推送，就会收到推送消息。</p>
<p><img src="/2018/08/12/PWA学习总结/push.png" alt=""></p>
<p>由于chrome浏览器的<code>push service</code>是FCM，需要翻墙和配置<a href="https://console.firebase.google.com/" target="_blank" rel="noopener">firbase</a>才能使用。firfox浏览器使用的是自家的<code>push service</code>，不需要其他操作就可以收到消息推送。</p>
<p><br></p>
<h4 id="5-2-Notification"><a href="#5-2-Notification" class="headerlink" title="5.2. Notification"></a>5.2. Notification</h4><p><code>Notification</code>主要是显示提醒界面和对提醒界面的操作。</p>
<p><br></p>
<h5 id="5-2-1-提醒界面"><a href="#5-2-1-提醒界面" class="headerlink" title="5.2.1. 提醒界面"></a>5.2.1. 提醒界面</h5><p>丰富的提醒界面可以是这样的：</p>
<p><img src="/2018/08/12/PWA学习总结/notification.png" alt=""></p>
<p>显示提醒界面的接口在5.1.3节中已经使用过：<code>showNotification(title,options)</code>，第一个参数<code>title</code>很明显是消息界面的标题，第二个参数<code>options</code>是消息界面其他相关的配置，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> options = &#123;</span><br><span class="line">    body : <span class="string">'邀请你一起学习，邀请你一起学习邀请你一起学习'</span>,     </span><br><span class="line">    icon : <span class="string">'/img/icon_128.png'</span>, </span><br><span class="line">    actions : [&#123;</span><br><span class="line">        action : <span class="string">'show-jd'</span>,</span><br><span class="line">        title : <span class="string">'去京东'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        action : <span class="string">'contact-me'</span>,</span><br><span class="line">        title : <span class="string">'联系我'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    tag : <span class="string">'pwa-starter'</span>,</span><br><span class="line">    renotify : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>title</code>、<code>options</code>配置对应的消息界面如下：</p>
<p><img src="/2018/08/12/PWA学习总结/signedNotice1.png" alt=""></p>
<p><img src="/2018/08/12/PWA学习总结/signedNotice2.png" alt=""></p>
<p><code>title</code>：标题，不限制字数，当文字过多以省略号显示<br><code>body</code>：简介，不限制字数，当文字过多以省略号显示<br><code>icon</code> ： 图片，未规定图片尺寸大小<br><code>actions</code> ： 新的按钮操作<br>    -<code>action</code> ：按钮的动作函数<br>    -<code>title</code> ：按钮的标题<br><code>tag</code> ： 消息界面唯一的标志<br><code>renotify</code> ： 表示是否重复多次显示消息界面，当设为<code>false</code>，出现过一次的<code>tag</code>消息，将不会再出现</p>
<p>将配置加入<code>serviceWorker.js</code>的<code>push</code>事件中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceWorker.js</span></span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'push'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = e.data;</span><br><span class="line">    <span class="keyword">if</span>(e.data)&#123;</span><br><span class="line">        data = data.json();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'push的数据为：'</span>,data);</span><br><span class="line">        <span class="keyword">var</span> title = data;</span><br><span class="line">        <span class="keyword">var</span> options = &#123;</span><br><span class="line">            body : <span class="string">'邀请你一起学习'</span>,</span><br><span class="line">            icon : <span class="string">'/img/icon_128.png'</span>,</span><br><span class="line">            actions : [&#123;</span><br><span class="line">                action : <span class="string">'show-jd'</span>,</span><br><span class="line">                title : <span class="string">'去京东'</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                action : <span class="string">'contact-me'</span>,</span><br><span class="line">                title : <span class="string">'联系我'</span></span><br><span class="line">            &#125;],</span><br><span class="line">            tag : <span class="string">'pwa-starter'</span>,</span><br><span class="line">            renotify : <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">        self.registration.showNotification(title,options);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'push没有任何数据'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以在<code>index.js</code>中通过点击某个按钮直接显示消息提醒，配置相同：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">...</span><br><span class="line"> <span class="built_in">document</span>.querySelector(<span class="string">'.J_notification'</span>).addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title = <span class="string">'PWA学习'</span>;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    registration.showNotification(title,options)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><br></p>
<h5 id="5-2-2-提醒交互"><a href="#5-2-2-提醒交互" class="headerlink" title="5.2.2. 提醒交互"></a>5.2.2. 提醒交互</h5><p>提醒界面已经出来了，那么怎么去捕获用户在提醒界面上的操作呢。</p>
<p>在Service Worker中，可以通过<code>notificationclick</code>去捕获用户的点击。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'notificationclick'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> action = e.action;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`action tag:<span class="subst">$&#123;e.notification.tag&#125;</span>`</span>,<span class="string">`action:<span class="subst">$&#123;action&#125;</span>`</span>,e);</span><br><span class="line">    <span class="keyword">switch</span>(action)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'show-jd'</span> : </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'show-jd'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'contact-me'</span> :</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'contact-me'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`未处理的action：<span class="subst">$&#123;e.action&#125;</span>`</span>);</span><br><span class="line">            action = <span class="string">'default'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e.notification.close(); <span class="comment">//关闭通知栏</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在<code>notificationclick</code>事件中，可以通过<code>e.notification.close()</code>关闭通知栏。还可以获取<code>action</code>，那么就可以根据<code>action</code>进行不同的操作。在上节中，我们加了<code>show-jd</code>和<code>contact-me</code>的<code>action</code>，那么我们可以这些<code>action</code>添加不同的操作，比如点击“去京东”，则新增标签页跳去京东首页，点击“联系我”，则唤起发给我的邮件。</p>
<p>但是Service Worker不能直接操作DOM，我们可以让Service Worker和客户端通信。在Service Worker中可以使用<code>postMessage</code>向客户端发送消息，而客户端可以用<code>message</code>事件捕获Service Worker发送的消息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'notificationclick'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> action = e.action;</span><br><span class="line">    ...</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(<span class="function"><span class="keyword">function</span>(<span class="params">clients</span>)</span>&#123;</span><br><span class="line">            clients.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">client</span>)</span>&#123;</span><br><span class="line">                client.postMessage(action);    <span class="comment">//向客户端发送用户点击的`action`。</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    e.notification.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用<code>e.waitUntil</code>可以在程序繁忙后也能保证将信息发送到客户端。</p>
<p>捕获<code>service worker</code>发送的消息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">navigator.serviceWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> action = e.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`用户点击的action是：<span class="subst">$&#123;e.data&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">switch</span>(action)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'show-jd'</span> :</span><br><span class="line">            location.href = <span class="string">'https://www.jd.com'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'contact-me'</span> :</span><br><span class="line">            location.href = <span class="string">'mailto:563282341@qq.com'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> :   <span class="comment">//点击除show-jd和contact-me区域，显示页面提示</span></span><br><span class="line">            <span class="built_in">document</span>.querySelector(<span class="string">'.tips'</span>).style.display = <span class="string">'block'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>还可以点击通知栏时切换到当前客户端标签页，也可以在未打开客户端时，打开客户端标签页：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'notificationclick'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> action = e.action;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    e.waitUntil(</span><br><span class="line">        self.clients.matchAll().then(<span class="function"><span class="keyword">function</span>(<span class="params">clients</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!clients || clients.length == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//打开标签页</span></span><br><span class="line">                self.clients.openWindow &amp;&amp; self.clients.openWindow(<span class="string">'http://127.0.0.1:3034'</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//切换到指定客户端页</span></span><br><span class="line">            clients[<span class="number">0</span>].focus &amp;&amp; clients[<span class="number">0</span>].focus();</span><br><span class="line">            ...</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    e.notification.close();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="5-3-兼容性"><a href="#5-3-兼容性" class="headerlink" title="5.3. 兼容性"></a>5.3. 兼容性</h4><p>在caniuse查看<a href="https://caniuse.com/#search=push" target="_blank" rel="noopener">Push API</a>和<a href="https://caniuse.com/#search=notification" target="_blank" rel="noopener">Notification API</a>的兼容性：</p>
<p><img src="/2018/08/12/PWA学习总结/pushUse.png" alt=""></p>
<p><img src="/2018/08/12/PWA学习总结/notificationUse.png" alt=""></p>
<p>1.<code>Push API</code>在ios safari不兼容，在Android和pc端兼容性较好。如果浏览器使用的是FCM的<code>push service</code>在国内不能使用。</p>
<p>2.<code>Notification API</code>在移动端兼容性较差，在pc端得到比较好的支持。其中<code>actions</code>目前只在Chrome浏览器支持。</p>
<p><br></p>
<h1 id="六、后台数据同步"><a href="#六、后台数据同步" class="headerlink" title="六、后台数据同步"></a>六、后台数据同步</h1><h4 id="6-1-后台同步介绍"><a href="#6-1-后台同步介绍" class="headerlink" title="6.1. 后台同步介绍"></a>6.1. 后台同步介绍</h4><p>当我们在页面进行某个操作，需要将数据提交后台，可能会因为网络慢或无网络，最后用户直接关闭网络，导致数据无法提交到后台，再次进入页面时，还需要重新进行同样的操作。那么后台同步功能的实现就能解决这样的问题，可以将操作保存在Service Worker，在有网络时，Service Worker将用户的操作同步到后台，大大的提升了用户体验。</p>
<p>后台同步的流程如下：<br>1.在浏览器中发起后台同步请求<br>2.在Service Worker中监听<code>sync</code>事件，并发起请求</p>
<p>接下来我们看看如何实现后台同步。</p>
<p><br></p>
<h4 id="6-2-实现后台同步"><a href="#6-2-实现后台同步" class="headerlink" title="6.2. 实现后台同步"></a>6.2. 实现后台同步</h4><p>后台同步的实现，需要依赖于Service Worker监听浏览器发起的<code>sync</code>后台同步事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'sync'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除此之外，后台同步还需要使用到<code>SyncManager</code>接口，通过<code>registration.sync</code>调用，返回包含<code>getTags</code>和<code>register</code>方法的<code>SyncManager</code>对象。</p>
<p><code>register(tag)</code>：发起同步，tag为唯一的同步请求标志，返回一个promise。</p>
<p><code>getTags()</code>：获取所有在SyncManager注册的tag，返回一个promise。</p>
<p><strong>1.在浏览器中发起后台同步请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator &amp;&amp; <span class="string">'SyncManager'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="comment">//在service worker激活成功后进行</span></span><br><span class="line">    navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tag = <span class="string">"sample_sync"</span>;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'.J_sync'</span>).addEventListener(<span class="string">'click'</span> , <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'同步后台'</span>,registration.sync)</span><br><span class="line"></span><br><span class="line">            registration.sync.register(tag).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'同步后台已触发'</span>,tag);</span><br><span class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'后台同步出发失败'</span>,err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.在Service Worker中监听<code>sync</code>事件，并发起请求</strong></p>
<p>假设在Nodejs中已经实现接口<code>/sync</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'sync'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> init = &#123;</span><br><span class="line">        method : <span class="string">'GET'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e.tag === <span class="string">'sample_sync'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> request = <span class="keyword">new</span> Request(<span class="string">`/sync?name=xxx`</span> , init);</span><br><span class="line">        </span><br><span class="line">        e.waitUntil(</span><br><span class="line">            fetch(request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用<code>waitUntil</code>可以保证在用户在页面关闭后，Service Worker可以继续发起请求，这样就可以在用户恢复网络时，Service Worker发起未完成的请求。</p>
<p><br></p>
<h4 id="6-3-提交数据到后台同步"><a href="#6-3-提交数据到后台同步" class="headerlink" title="6.3. 提交数据到后台同步"></a>6.3. 提交数据到后台同步</h4><p>有时候我们的操作需要将我们录入的数据提交到后台，比如提交姓名、图片等，那么就需要我们将数据提交到Service Worker中，可以通过使用<code>postMessage</code>提交数据。</p>
<p><strong>1.postMessage提交数据</strong></p>
<p>postMessage传递数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line">navigator.serviceWorker.ready.then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tag = <span class="string">'sample_sync_event'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'.J_sync_event'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">            registration.sync.register(tag).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`后台同步已触发：<span class="subst">$&#123;tag&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> inputValue = <span class="built_in">document</span>.querySelector(<span class="string">'#input'</span>).value;</span><br><span class="line">                <span class="keyword">var</span> msg = <span class="built_in">JSON</span>.stringify(&#123; <span class="attr">type</span> : <span class="string">'bgsync'</span> , <span class="attr">msg</span> : &#123;<span class="attr">name</span> : inputValue&#125;&#125;);</span><br><span class="line">                navigator.serviceWorker.controller.postMessage(msg);</span><br><span class="line">            &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`后台同步触发失败：<span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>数据传递到Service Worker，监听<code>message</code>事件和监听<code>sync</code>事件需要交叉处理，为了保证Service Worker拿到数据后再发起请求，创建<code>DealData</code>函数用于处理数据，并解耦<code>message</code>事件和<code>sync</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.jd</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DealData</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.tagDatas = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存储tag和回调函数</span></span><br><span class="line">    once(tag , callback)&#123;</span><br><span class="line">        <span class="keyword">this</span>.tagDatas[tag] || (<span class="keyword">this</span>.tagDatas[tag] = []);</span><br><span class="line">        <span class="keyword">this</span>.tagDatas[tag].push(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//收到数据后，执行回调函数</span></span><br><span class="line">    trigger(tag , data)&#123;</span><br><span class="line">        <span class="keyword">this</span>.tagDatas[tag] = <span class="keyword">this</span>.tagDatas[tag] || [];</span><br><span class="line">        <span class="keyword">let</span> tagCallback ;</span><br><span class="line">        <span class="keyword">while</span>(tagCallback = <span class="keyword">this</span>.tagDatas[tag].shift())&#123;</span><br><span class="line">            tagCallback(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dealData = <span class="keyword">new</span> DealData();</span><br></pre></td></tr></table></figure>
<p>监听message事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'message'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data),</span><br><span class="line">        type = data.type,</span><br><span class="line">        msg = data.msg;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`service worker收到消息 type: <span class="subst">$&#123;type&#125;</span> ; msg : <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(msg)&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    dealData.trigger(type , msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>监听sync事件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//serviceworker.js</span></span><br><span class="line">self.addEventListener(<span class="string">'sync'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> init = &#123;</span><br><span class="line">        method : <span class="string">'GET'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(e.tag === <span class="string">'sample_sync'</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.tag === <span class="string">'sample_sync_event'</span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> msgPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</span><br><span class="line">            dealData.once(<span class="string">'bgsync'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;);</span><br><span class="line">            setTimeout(resolve , <span class="number">5000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        e.waitUntil(</span><br><span class="line">            msgPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> name = data &amp;&amp; data.name ? data.name : <span class="string">'anonymous'</span>;</span><br><span class="line">                <span class="keyword">var</span> request = <span class="keyword">new</span> Request(<span class="string">`sync?name=<span class="subst">$&#123;name&#125;</span>`</span> , init);</span><br><span class="line">                <span class="keyword">return</span> fetch(request)</span><br><span class="line">            &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>到这里就可以将数据传递到后台同步。</p>
<p><br></p>
<h4 id="6-4-兼容性"><a href="#6-4-兼容性" class="headerlink" title="6.4. 兼容性"></a>6.4. 兼容性</h4><p>从caniuse查看<a href="https://caniuse.com/#search=background%20sync" target="_blank" rel="noopener">sync API</a>的兼容性：</p>
<p><img src="/2018/08/12/PWA学习总结/syncUse.png" alt=""></p>
<p>很可惜，目前只有Chrome浏览器和Android的Chrome、UC浏览器支持Sycn API。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>通过PWA的学习和实践，发现PWA功能的实现给页面的体验带来了更好的突破。虽然目前PWA的支持率不高，但是Google、Microsoft、Apple已经全数宣布支持PWA技术，许多平台已经开始引入了PWA技术，比如淘宝、饿了么、美团等。相信未来PWA的普及会带来更大的突破。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://alienzhou.gitbook.io/learning-pwa/" target="_blank" rel="noopener">PWA学习与实践（https://alienzhou.gitbook.io/learning-pwa/）</a><br><a href="https://developers.google.com/web/ilt/pwa/" target="_blank" rel="noopener">Progressive Web Apps Training（https://developers.google.com/web/ilt/pwa/）</a></p>
</div></article></div></section><footer><div class="paginator"><a href="/2018/09/24/正则表达式/" class="prev">PRVE</a><a href="/2018/08/02/水波纹进度条实现原理/" class="next">NEXT</a></div><div data-thread-key="2018/08/12/PWA学习总结/" data-title="PWA学习总结" data-url="http://zengzoe.github.io/2018/08/12/PWA学习总结/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"zengzoe"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2016 - 2018 <a href="http://zengzoe.github.io">Zeng Zoe</a>, unless otherwise noted.</p><p style="display:none !important;"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span><span id="busuanzi_container_site_uv">本站总访客数<span id="busuanzi_value_site_uv"></span>人次</span></p></div></footer><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>