title: 讲讲ECMAScript 6那些事
date: 2016-09-14 17:56:43
tags:
---
ECMAScript 6（下面简称ES6）已于2015年6月正式发布，将会成为Javascript语言新的标准。ES6提供的新语法与新特性给JSer们带来不一样的体验。

虽然目前没有浏览器对ES6全部特性能够完美的支持，可以通过[http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)查看浏览器的支持情况。但是可以通过多种转换器来体验ES6更多的特性。比如最常用的Babel。ES6发布至今，许多浏览器的最新版本对ES6大部分特性都实现了。如果想要更好的体验ES6的新特性和新语法，可以使用转换器。Babel转码器是使用比较广泛的，可以将ES6转换成ES5。

这篇博客将会介绍ES6比较常用的语法特性，希望能够给大家带来收获。在线测试代码可以点击[这里](http://babeljs.cn/repl/)。

## 目录
 ** [1.let和const](#var) **
 ** [2.箭头函数](#arrow) **
 ** [3.字符串](#string) **
 ** [4.解构赋值](#deconstruct) ** 
 ** [5.正则](#regexp) **

------

## <span id="var">1.let和const</span>
`let`和`const`是ES6新增的声明变量的命令。使用方法与`var`相似，不过`let`和`const`声明的变量只能在所在的代码块使用，也就是块级作用域。
`const`即constant，用来声明只读的常量，一旦声明就必须赋值，声明常量之后不可赋值，但是可以继续添加属性。
例如：
```
const Pi;  // Missing initializer in const declaration
```
`const`声明常量时必须赋值，否则报错。
```
const Pi = 3.14;
Pi = 3;     //Assignment to constant variable.
```
由于`const`声明的Pi是常量，如果初始化后对其赋值，则报错。
```
const obj = {};
obj.name = "张三";
console.log(obj);           // {name: "张三"}
obj = {};              //Assignment to constant variable.
```
常量`obj`是一个对象，可以对其添加属性。
`let`其与`var`的不同体现在三点：
** (1)不存在变量提升。**
使用`var`：
``` javascript
var str = "hello";
    function getStr(arg) {
        if (arg) {
            var str = 'hello world';
            return str;
        }
        return str;
    }
    console.log(getStr(false));  //undefined
```
使用`let`:
``` javascript
let str = "hello";
function getStr(arg) {
    if (arg) {
        let str = 'hello world';
        return str;
    }
    return str;
}
console.log(getStr(false));  //hello
```
第一个例子中，由于if内声明的变量会被提升到函数头部，所以返回了undefined。第二个例子由于let声明的变量不会发生变量提升，if内声明的变量只能在当前所在的代码块使用，所以直接返回hello。
** (2)暂时性死区。**
`let`声明的变量只能在代码块中使用，同时必须在声明后才能使用，否则会报错,这就是暂时性死区。
```
if(true){
    console.log(str);       //ReferenceError: str is not defined
    let str = "hello";
}
```
在`let`命令声明str之前，上面的代码都属于str的"死区"。
如果将上面的`let`变成`var`,则返回undefined：
```
if(true){
    console.log(str);       //undefined
    var str = "hello";
}
```

** (3)不允许重复声明。**
`let`不允许在相同的作用域内，重复声明同一个变量。而`var`重复声明变量，则后面的变量会覆盖前面声明的变量。
```javascript
if(true){
    let str = "hello";
    console.log(str);

    let str = "world";
    console.log(str); //SyntaxError: Identifier 'str' has already been declared
}
```
因此，对于`const`、`let`和`var`三个命令，当想要定义常量的时候可以选择`const`。当声明一个变量赋值后还会修改的可以选择`let`或`var`，当使用于循环计数或者算法，建议优先选择`let`。

------

## <span id="arrow">2.箭头函数</span>
箭头函数即使用箭头“=>”定义函数，使用箭头函数有两个目的：
1.可以大大的减少代码量。
2.与父作用域共享关键字this。
```
    let result = [1,2,3,4].map(i=>i*i);
```
箭头左边是输入的参数，右边是进行的操作以及返回的值。
上面代码等同于es5：
```
    let rusult = [1,2,3,4].map(function(i){
            return i*i;
        })
```
如果函数不需要参数或者需要多个参数，需使用用圆号。
```
let result = () => 5;

let result2 = [1,2,3,4].map((i,item)=>console.log(i:item));
```
如果箭头右边执行多行命令，则需使用大括号,并使用return返回。
```
let result = [1,2,3,4].map(i=>{return i*i;})
```
如果返回的是对象，则需在大括号外层添加中括号。
```
let result = i => ({id :i ,name : "cici"})
```
可代替立即执行函数。
```
(x => x*2)(3);      //6
```
在箭头函数，`this`指向的是定义时所在的对象，而不是使用时所在的对象。
例子：
```
//ES5
function Person(data){
    this.name = data.name;
    this.age = data.ag;
    this.getInfo = function(){
        console.log(this.name + " " + this.age);
    }
    this.sayHello = function(){
        setTimeout(function(){
            console.log(this);
        },1000)
    }
}

let dudu = new Person({
    name : "dudu",
    age : 20
});

dudu.getInfo();       //dudu 20
dudu.sayHello();      //windows

```
在超时调用的代码都是在全局作用于中执行，所以函数中的`this`的值指向了window对象。而箭头函数可以保持作用域，保证`this`的指向不会变:
```
 function Person(data){
    this.name = data.name;
    this.age = data.age;
    this.getInfo = function(){
        console.log(this.name + " " + this.age);
    }
    this.sayHello = function(){
        setTimeout(() => console.log(this),1000)
    }
}

let dudu = new Person({
    name : "dudu",
    age : 20
});

dudu.getInfo();               //dudu 20
dudu.sayHello();             //Person {name: "dudu", age: 20}
```
在sayHello函数中，使用了箭头函数，当前作用域是在person对象的一个方法中，箭头函数生成的临时函数的作用域也就是person对象的作用域。

---

## <span id="string">3.字符串</span>
在ES6中，添加了许多对于字符串的接口。
**（1）includes、startsWith、endsWith **
之前我们是通过`indexOf`来判断字符串是否包含某个字符串：
```
let str = "hello world";
console.log(str.indexOf("o")>-1);
```
在ES6中，增加了三个新方法。
`includes`判断字符串是否包含某字符串，返回布尔值。
`startsWith`判断字符串是否以某字符串开头，返回布尔值。
`endsWith`判断字符串是否以某字符串结尾，返回布尔值。
```
    let str = "hello world";
    console.log(str.includes("wor"));       //true
    console.log(str.startsWith("he"));       //true
    console.log(str.endsWith("ld"));       //true
      
    console.log(str.includes("llo",1));         //true
    console.log(str.includes("llo",5));        //false

    console.log(str.startsWith("llo",2));        //true
    console.log(str.startsWith("llo",3));        //false

    console.log(str.endsWith("llo",5));        //true
    console.log(str.endsWith("llo",9));        //false
```
在上面代码中，加入了第二个参数。`includes`和`startsWith`的第二个参数代表搜索的开始位置。而`endsWith`代表了只搜索字符串的前几位。

** (2) repeat ** 
`repeat`方法用来返回重复多次的字符串。
```
let str = "abc";
console.log(str.repeat(2));         // "abcabc"
console.log(str.repeat("3"));         // "abcabc"
console.log(str.repeat("2.8"));        // "abcabc"
console.log(str.repeat("a"));           // ""   
console.log(str.repeat());              // ""
console.log(str.repeat(0));              // ""
console.log(str.repeat(-1));            // 报错：  Uncaught RangeError: Invalid count value
```
`repeat`参数为重复字符串的次数，如果参数是字符串，则会先转换成数字，否则输出空字符串；如果是小数，则会被去整；如果参数是0或者不添加参数，则返回空字符串；如果是负数，则会报错。

** (3) 模版字符串 **
模版字符串使用反引号“`”标识符，它的出现让字符串的使用变得更加方便。模版字符串有两大特点：
a.可以在字符串中是使用变量。
b.字符串换行符空白符被保留。

** a.可以在字符串中是使用变量 **
```
let name = "dudu";
let age = 20;
console.log(`my name is ${name},i am ${age} years old`);     // "my name is dudu,i am 20 years old"
```
在模版字符串中，使用`${}`包含变量。也可在变量进行算法运算或执行函数等操作。
```
let a = 5;
let b = 10;
console.log(`5加10等于${a+b}，5乘10等于${a*b}`)    //5加10等于15，5乘10等于50


function add(x,y){
    return x+y;
}
console.log(`5加10等于${add(a,b)}`)           //5加10等于15
```

** b.字符串换行符空白符被保留 **
在ES6之前：
```
let str = "hi,"
          + "i am dudu" 
          + "i am 20 years old";

console.log(str);           //hi,i am dudui am 20 years old
```
ES6：
```
let str2 = `hi,
            i am dudu,
            i am 20 years old`;
console.log(str2);
//hi,
//i am dudu,
// i am 20 years old
```
通过上面的示例可以看出，模版字符串的出现给字符串的使用带了很大的便利。
---

## <span id="deconstruct">4.解构赋值</span>
解构赋值可以从数组或对象中提取出值为赋值给不同的变量。
** （1）数组的解构赋值 **
ES6之前：
```
var arr = [1,2,3];
var a = arr[0];
var b = arr[1];
var c = arr[2];
```
ES6:
```
let [a,b,c] = [1,2,3];
console.log(a,b,c);     //1 2 3
```
数组的解构赋值按照数据的变量顺序进行赋值。

** （2）对象的解构赋值 **
ES6之前：
```
var obj = {name : "dudu",age : 20,city : "shenzhen"};
var name = obj.name;
var age = obj.age;
var city = obj.city;
```
ES6:
```
let {name,age,city} = {name : "dudu",age : 20,city : "shenzhen"};
console.log(name,age,city);
```
对象的解构赋值顺序可以打乱，按照变量名进行赋值。

** （3）字符串的解构赋值 **
ES6之前：
```
var str = "hello";
var a = str[0];
var b = str[1];
var c = str[2];
var d = str[3];
var e = str[4];
```
ES6：
```
let [a,b,c,d,e] = 'hello';
console.log(a,b,c,d,e);        //h e l l o
```

** (4)函数参数的解构赋值 **
函数参数的解构赋值最大的特点是能够为参数设定默认值。
```
function foo({name="dudu",age=20} = {}){
    console.log([name,age]);
}
foo();       //["dudu", 20]
foo({name : "cici"}) //["cici", 20]
foo({age : 22}); //["dudu", 22]
foo({name : "cici",age :22});//["cici", 22]
```
注意下面代码参数的写法与上面代码参数的写法不同：
```
function foo({name,age} = {name : "dudu",age : 20}){
    console.log([name,age]);
}
foo();   //["dudu", 20]
foo({});         //[undefined, undefined]
foo({name : "cici"})     //["cici", undefined]
foo({age : 22});         //[undefined, 22]
foo({name : "cici",age :22});        //["cici", 22]
```
第一个代码块中，是为参数中对象的每一个名赋值，第二个代码块中是直接为对象赋值。

---

## <span id="regexp">5.正则</span>
ES6中新增的正则表达式特性有：
（1）新的`y`修饰符，用于




